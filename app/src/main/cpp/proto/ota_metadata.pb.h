// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ota_metadata.proto

#ifndef PROTOBUF_INCLUDED_ota_5fmetadata_2eproto
#define PROTOBUF_INCLUDED_ota_5fmetadata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ota_5fmetadata_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_ota_5fmetadata_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
namespace build {
namespace tools {
namespace releasetools {
class ApexInfo;
class ApexInfoDefaultTypeInternal;
extern ApexInfoDefaultTypeInternal _ApexInfo_default_instance_;
class ApexMetadata;
class ApexMetadataDefaultTypeInternal;
extern ApexMetadataDefaultTypeInternal _ApexMetadata_default_instance_;
class DeviceState;
class DeviceStateDefaultTypeInternal;
extern DeviceStateDefaultTypeInternal _DeviceState_default_instance_;
class OtaMetadata;
class OtaMetadataDefaultTypeInternal;
extern OtaMetadataDefaultTypeInternal _OtaMetadata_default_instance_;
class OtaMetadata_PropertyFilesEntry_DoNotUse;
class OtaMetadata_PropertyFilesEntry_DoNotUseDefaultTypeInternal;
extern OtaMetadata_PropertyFilesEntry_DoNotUseDefaultTypeInternal _OtaMetadata_PropertyFilesEntry_DoNotUse_default_instance_;
class PartitionState;
class PartitionStateDefaultTypeInternal;
extern PartitionStateDefaultTypeInternal _PartitionState_default_instance_;
}  // namespace releasetools
}  // namespace tools
}  // namespace build
namespace google {
namespace protobuf {
template<> ::build::tools::releasetools::ApexInfo* Arena::CreateMaybeMessage<::build::tools::releasetools::ApexInfo>(Arena*);
template<> ::build::tools::releasetools::ApexMetadata* Arena::CreateMaybeMessage<::build::tools::releasetools::ApexMetadata>(Arena*);
template<> ::build::tools::releasetools::DeviceState* Arena::CreateMaybeMessage<::build::tools::releasetools::DeviceState>(Arena*);
template<> ::build::tools::releasetools::OtaMetadata* Arena::CreateMaybeMessage<::build::tools::releasetools::OtaMetadata>(Arena*);
template<> ::build::tools::releasetools::OtaMetadata_PropertyFilesEntry_DoNotUse* Arena::CreateMaybeMessage<::build::tools::releasetools::OtaMetadata_PropertyFilesEntry_DoNotUse>(Arena*);
template<> ::build::tools::releasetools::PartitionState* Arena::CreateMaybeMessage<::build::tools::releasetools::PartitionState>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace build {
namespace tools {
namespace releasetools {

enum OtaMetadata_OtaType {
  OtaMetadata_OtaType_UNKNOWN = 0,
  OtaMetadata_OtaType_AB = 1,
  OtaMetadata_OtaType_BLOCK = 2,
  OtaMetadata_OtaType_BRICK = 3,
  OtaMetadata_OtaType_OtaMetadata_OtaType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  OtaMetadata_OtaType_OtaMetadata_OtaType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool OtaMetadata_OtaType_IsValid(int value);
const OtaMetadata_OtaType OtaMetadata_OtaType_OtaType_MIN = OtaMetadata_OtaType_UNKNOWN;
const OtaMetadata_OtaType OtaMetadata_OtaType_OtaType_MAX = OtaMetadata_OtaType_BRICK;
const int OtaMetadata_OtaType_OtaType_ARRAYSIZE = OtaMetadata_OtaType_OtaType_MAX + 1;

// ===================================================================

class PartitionState :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:build.tools.releasetools.PartitionState) */ {
 public:
  PartitionState();
  virtual ~PartitionState();

  PartitionState(const PartitionState& from);

  inline PartitionState& operator=(const PartitionState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartitionState(PartitionState&& from) noexcept
    : PartitionState() {
    *this = ::std::move(from);
  }

  inline PartitionState& operator=(PartitionState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const PartitionState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartitionState* internal_default_instance() {
    return reinterpret_cast<const PartitionState*>(
               &_PartitionState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(PartitionState* other);
  friend void swap(PartitionState& a, PartitionState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartitionState* New() const final {
    return CreateMaybeMessage<PartitionState>(nullptr);
  }

  PartitionState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PartitionState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PartitionState& from);
  void MergeFrom(const PartitionState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PartitionState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string device = 2;
  int device_size() const;
  void clear_device();
  static const int kDeviceFieldNumber = 2;
  const ::std::string& device(int index) const;
  ::std::string* mutable_device(int index);
  void set_device(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_device(int index, ::std::string&& value);
  #endif
  void set_device(int index, const char* value);
  void set_device(int index, const char* value, size_t size);
  ::std::string* add_device();
  void add_device(const ::std::string& value);
  #if LANG_CXX11
  void add_device(::std::string&& value);
  #endif
  void add_device(const char* value);
  void add_device(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& device() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_device();

  // repeated string build = 3;
  int build_size() const;
  void clear_build();
  static const int kBuildFieldNumber = 3;
  const ::std::string& build(int index) const;
  ::std::string* mutable_build(int index);
  void set_build(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_build(int index, ::std::string&& value);
  #endif
  void set_build(int index, const char* value);
  void set_build(int index, const char* value, size_t size);
  ::std::string* add_build();
  void add_build(const ::std::string& value);
  #if LANG_CXX11
  void add_build(::std::string&& value);
  #endif
  void add_build(const char* value);
  void add_build(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& build() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_build();

  // string partition_name = 1;
  void clear_partition_name();
  static const int kPartitionNameFieldNumber = 1;
  const ::std::string& partition_name() const;
  void set_partition_name(const ::std::string& value);
  #if LANG_CXX11
  void set_partition_name(::std::string&& value);
  #endif
  void set_partition_name(const char* value);
  void set_partition_name(const char* value, size_t size);
  ::std::string* mutable_partition_name();
  ::std::string* release_partition_name();
  void set_allocated_partition_name(::std::string* partition_name);

  // string version = 4;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:build.tools.releasetools.PartitionState)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> device_;
  ::google::protobuf::RepeatedPtrField<::std::string> build_;
  ::google::protobuf::internal::ArenaStringPtr partition_name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ota_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class DeviceState :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:build.tools.releasetools.DeviceState) */ {
 public:
  DeviceState();
  virtual ~DeviceState();

  DeviceState(const DeviceState& from);

  inline DeviceState& operator=(const DeviceState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeviceState(DeviceState&& from) noexcept
    : DeviceState() {
    *this = ::std::move(from);
  }

  inline DeviceState& operator=(DeviceState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const DeviceState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceState* internal_default_instance() {
    return reinterpret_cast<const DeviceState*>(
               &_DeviceState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(DeviceState* other);
  friend void swap(DeviceState& a, DeviceState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeviceState* New() const final {
    return CreateMaybeMessage<DeviceState>(nullptr);
  }

  DeviceState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeviceState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DeviceState& from);
  void MergeFrom(const DeviceState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string device = 1;
  int device_size() const;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  const ::std::string& device(int index) const;
  ::std::string* mutable_device(int index);
  void set_device(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_device(int index, ::std::string&& value);
  #endif
  void set_device(int index, const char* value);
  void set_device(int index, const char* value, size_t size);
  ::std::string* add_device();
  void add_device(const ::std::string& value);
  #if LANG_CXX11
  void add_device(::std::string&& value);
  #endif
  void add_device(const char* value);
  void add_device(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& device() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_device();

  // repeated string build = 2;
  int build_size() const;
  void clear_build();
  static const int kBuildFieldNumber = 2;
  const ::std::string& build(int index) const;
  ::std::string* mutable_build(int index);
  void set_build(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_build(int index, ::std::string&& value);
  #endif
  void set_build(int index, const char* value);
  void set_build(int index, const char* value, size_t size);
  ::std::string* add_build();
  void add_build(const ::std::string& value);
  #if LANG_CXX11
  void add_build(::std::string&& value);
  #endif
  void add_build(const char* value);
  void add_build(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& build() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_build();

  // repeated .build.tools.releasetools.PartitionState partition_state = 7;
  int partition_state_size() const;
  void clear_partition_state();
  static const int kPartitionStateFieldNumber = 7;
  ::build::tools::releasetools::PartitionState* mutable_partition_state(int index);
  ::google::protobuf::RepeatedPtrField< ::build::tools::releasetools::PartitionState >*
      mutable_partition_state();
  const ::build::tools::releasetools::PartitionState& partition_state(int index) const;
  ::build::tools::releasetools::PartitionState* add_partition_state();
  const ::google::protobuf::RepeatedPtrField< ::build::tools::releasetools::PartitionState >&
      partition_state() const;

  // string build_incremental = 3;
  void clear_build_incremental();
  static const int kBuildIncrementalFieldNumber = 3;
  const ::std::string& build_incremental() const;
  void set_build_incremental(const ::std::string& value);
  #if LANG_CXX11
  void set_build_incremental(::std::string&& value);
  #endif
  void set_build_incremental(const char* value);
  void set_build_incremental(const char* value, size_t size);
  ::std::string* mutable_build_incremental();
  ::std::string* release_build_incremental();
  void set_allocated_build_incremental(::std::string* build_incremental);

  // string sdk_level = 5;
  void clear_sdk_level();
  static const int kSdkLevelFieldNumber = 5;
  const ::std::string& sdk_level() const;
  void set_sdk_level(const ::std::string& value);
  #if LANG_CXX11
  void set_sdk_level(::std::string&& value);
  #endif
  void set_sdk_level(const char* value);
  void set_sdk_level(const char* value, size_t size);
  ::std::string* mutable_sdk_level();
  ::std::string* release_sdk_level();
  void set_allocated_sdk_level(::std::string* sdk_level);

  // string security_patch_level = 6;
  void clear_security_patch_level();
  static const int kSecurityPatchLevelFieldNumber = 6;
  const ::std::string& security_patch_level() const;
  void set_security_patch_level(const ::std::string& value);
  #if LANG_CXX11
  void set_security_patch_level(::std::string&& value);
  #endif
  void set_security_patch_level(const char* value);
  void set_security_patch_level(const char* value, size_t size);
  ::std::string* mutable_security_patch_level();
  ::std::string* release_security_patch_level();
  void set_allocated_security_patch_level(::std::string* security_patch_level);

  // int64 timestamp = 4;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:build.tools.releasetools.DeviceState)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> device_;
  ::google::protobuf::RepeatedPtrField<::std::string> build_;
  ::google::protobuf::RepeatedPtrField< ::build::tools::releasetools::PartitionState > partition_state_;
  ::google::protobuf::internal::ArenaStringPtr build_incremental_;
  ::google::protobuf::internal::ArenaStringPtr sdk_level_;
  ::google::protobuf::internal::ArenaStringPtr security_patch_level_;
  ::google::protobuf::int64 timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ota_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ApexInfo :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:build.tools.releasetools.ApexInfo) */ {
 public:
  ApexInfo();
  virtual ~ApexInfo();

  ApexInfo(const ApexInfo& from);

  inline ApexInfo& operator=(const ApexInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ApexInfo(ApexInfo&& from) noexcept
    : ApexInfo() {
    *this = ::std::move(from);
  }

  inline ApexInfo& operator=(ApexInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ApexInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApexInfo* internal_default_instance() {
    return reinterpret_cast<const ApexInfo*>(
               &_ApexInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ApexInfo* other);
  friend void swap(ApexInfo& a, ApexInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ApexInfo* New() const final {
    return CreateMaybeMessage<ApexInfo>(nullptr);
  }

  ApexInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ApexInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ApexInfo& from);
  void MergeFrom(const ApexInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ApexInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string package_name = 1;
  void clear_package_name();
  static const int kPackageNameFieldNumber = 1;
  const ::std::string& package_name() const;
  void set_package_name(const ::std::string& value);
  #if LANG_CXX11
  void set_package_name(::std::string&& value);
  #endif
  void set_package_name(const char* value);
  void set_package_name(const char* value, size_t size);
  ::std::string* mutable_package_name();
  ::std::string* release_package_name();
  void set_allocated_package_name(::std::string* package_name);

  // int64 version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::google::protobuf::int64 version() const;
  void set_version(::google::protobuf::int64 value);

  // int64 decompressed_size = 4;
  void clear_decompressed_size();
  static const int kDecompressedSizeFieldNumber = 4;
  ::google::protobuf::int64 decompressed_size() const;
  void set_decompressed_size(::google::protobuf::int64 value);

  // int64 source_version = 5;
  void clear_source_version();
  static const int kSourceVersionFieldNumber = 5;
  ::google::protobuf::int64 source_version() const;
  void set_source_version(::google::protobuf::int64 value);

  // bool is_compressed = 3;
  void clear_is_compressed();
  static const int kIsCompressedFieldNumber = 3;
  bool is_compressed() const;
  void set_is_compressed(bool value);

  // @@protoc_insertion_point(class_scope:build.tools.releasetools.ApexInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr package_name_;
  ::google::protobuf::int64 version_;
  ::google::protobuf::int64 decompressed_size_;
  ::google::protobuf::int64 source_version_;
  bool is_compressed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ota_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ApexMetadata :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:build.tools.releasetools.ApexMetadata) */ {
 public:
  ApexMetadata();
  virtual ~ApexMetadata();

  ApexMetadata(const ApexMetadata& from);

  inline ApexMetadata& operator=(const ApexMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ApexMetadata(ApexMetadata&& from) noexcept
    : ApexMetadata() {
    *this = ::std::move(from);
  }

  inline ApexMetadata& operator=(ApexMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ApexMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApexMetadata* internal_default_instance() {
    return reinterpret_cast<const ApexMetadata*>(
               &_ApexMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ApexMetadata* other);
  friend void swap(ApexMetadata& a, ApexMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ApexMetadata* New() const final {
    return CreateMaybeMessage<ApexMetadata>(nullptr);
  }

  ApexMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ApexMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ApexMetadata& from);
  void MergeFrom(const ApexMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ApexMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .build.tools.releasetools.ApexInfo apex_info = 1;
  int apex_info_size() const;
  void clear_apex_info();
  static const int kApexInfoFieldNumber = 1;
  ::build::tools::releasetools::ApexInfo* mutable_apex_info(int index);
  ::google::protobuf::RepeatedPtrField< ::build::tools::releasetools::ApexInfo >*
      mutable_apex_info();
  const ::build::tools::releasetools::ApexInfo& apex_info(int index) const;
  ::build::tools::releasetools::ApexInfo* add_apex_info();
  const ::google::protobuf::RepeatedPtrField< ::build::tools::releasetools::ApexInfo >&
      apex_info() const;

  // @@protoc_insertion_point(class_scope:build.tools.releasetools.ApexMetadata)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::build::tools::releasetools::ApexInfo > apex_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ota_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class OtaMetadata_PropertyFilesEntry_DoNotUse : public ::google::protobuf::internal::MapEntryLite<OtaMetadata_PropertyFilesEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntryLite<OtaMetadata_PropertyFilesEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  OtaMetadata_PropertyFilesEntry_DoNotUse();
  OtaMetadata_PropertyFilesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const OtaMetadata_PropertyFilesEntry_DoNotUse& other);
  static const OtaMetadata_PropertyFilesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const OtaMetadata_PropertyFilesEntry_DoNotUse*>(&_OtaMetadata_PropertyFilesEntry_DoNotUse_default_instance_); }
};

// -------------------------------------------------------------------

class OtaMetadata :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:build.tools.releasetools.OtaMetadata) */ {
 public:
  OtaMetadata();
  virtual ~OtaMetadata();

  OtaMetadata(const OtaMetadata& from);

  inline OtaMetadata& operator=(const OtaMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OtaMetadata(OtaMetadata&& from) noexcept
    : OtaMetadata() {
    *this = ::std::move(from);
  }

  inline OtaMetadata& operator=(OtaMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const OtaMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OtaMetadata* internal_default_instance() {
    return reinterpret_cast<const OtaMetadata*>(
               &_OtaMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(OtaMetadata* other);
  friend void swap(OtaMetadata& a, OtaMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OtaMetadata* New() const final {
    return CreateMaybeMessage<OtaMetadata>(nullptr);
  }

  OtaMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OtaMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const OtaMetadata& from);
  void MergeFrom(const OtaMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OtaMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  typedef OtaMetadata_OtaType OtaType;
  static const OtaType UNKNOWN =
    OtaMetadata_OtaType_UNKNOWN;
  static const OtaType AB =
    OtaMetadata_OtaType_AB;
  static const OtaType BLOCK =
    OtaMetadata_OtaType_BLOCK;
  static const OtaType BRICK =
    OtaMetadata_OtaType_BRICK;
  static inline bool OtaType_IsValid(int value) {
    return OtaMetadata_OtaType_IsValid(value);
  }
  static const OtaType OtaType_MIN =
    OtaMetadata_OtaType_OtaType_MIN;
  static const OtaType OtaType_MAX =
    OtaMetadata_OtaType_OtaType_MAX;
  static const int OtaType_ARRAYSIZE =
    OtaMetadata_OtaType_OtaType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // map<string, string> property_files = 4;
  int property_files_size() const;
  void clear_property_files();
  static const int kPropertyFilesFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      property_files() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_property_files();

  // .build.tools.releasetools.DeviceState precondition = 5;
  bool has_precondition() const;
  void clear_precondition();
  static const int kPreconditionFieldNumber = 5;
  const ::build::tools::releasetools::DeviceState& precondition() const;
  ::build::tools::releasetools::DeviceState* release_precondition();
  ::build::tools::releasetools::DeviceState* mutable_precondition();
  void set_allocated_precondition(::build::tools::releasetools::DeviceState* precondition);

  // .build.tools.releasetools.DeviceState postcondition = 6;
  bool has_postcondition() const;
  void clear_postcondition();
  static const int kPostconditionFieldNumber = 6;
  const ::build::tools::releasetools::DeviceState& postcondition() const;
  ::build::tools::releasetools::DeviceState* release_postcondition();
  ::build::tools::releasetools::DeviceState* mutable_postcondition();
  void set_allocated_postcondition(::build::tools::releasetools::DeviceState* postcondition);

  // .build.tools.releasetools.OtaMetadata.OtaType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::build::tools::releasetools::OtaMetadata_OtaType type() const;
  void set_type(::build::tools::releasetools::OtaMetadata_OtaType value);

  // bool wipe = 2;
  void clear_wipe();
  static const int kWipeFieldNumber = 2;
  bool wipe() const;
  void set_wipe(bool value);

  // bool downgrade = 3;
  void clear_downgrade();
  static const int kDowngradeFieldNumber = 3;
  bool downgrade() const;
  void set_downgrade(bool value);

  // bool retrofit_dynamic_partitions = 7;
  void clear_retrofit_dynamic_partitions();
  static const int kRetrofitDynamicPartitionsFieldNumber = 7;
  bool retrofit_dynamic_partitions() const;
  void set_retrofit_dynamic_partitions(bool value);

  // bool spl_downgrade = 9;
  void clear_spl_downgrade();
  static const int kSplDowngradeFieldNumber = 9;
  bool spl_downgrade() const;
  void set_spl_downgrade(bool value);

  // int64 required_cache = 8;
  void clear_required_cache();
  static const int kRequiredCacheFieldNumber = 8;
  ::google::protobuf::int64 required_cache() const;
  void set_required_cache(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:build.tools.releasetools.OtaMetadata)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::MapFieldLite<
      OtaMetadata_PropertyFilesEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > property_files_;
  ::build::tools::releasetools::DeviceState* precondition_;
  ::build::tools::releasetools::DeviceState* postcondition_;
  int type_;
  bool wipe_;
  bool downgrade_;
  bool retrofit_dynamic_partitions_;
  bool spl_downgrade_;
  ::google::protobuf::int64 required_cache_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ota_5fmetadata_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PartitionState

// string partition_name = 1;
inline void PartitionState::clear_partition_name() {
  partition_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PartitionState::partition_name() const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.PartitionState.partition_name)
  return partition_name_.GetNoArena();
}
inline void PartitionState::set_partition_name(const ::std::string& value) {
  
  partition_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:build.tools.releasetools.PartitionState.partition_name)
}
#if LANG_CXX11
inline void PartitionState::set_partition_name(::std::string&& value) {
  
  partition_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:build.tools.releasetools.PartitionState.partition_name)
}
#endif
inline void PartitionState::set_partition_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  partition_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:build.tools.releasetools.PartitionState.partition_name)
}
inline void PartitionState::set_partition_name(const char* value, size_t size) {
  
  partition_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:build.tools.releasetools.PartitionState.partition_name)
}
inline ::std::string* PartitionState::mutable_partition_name() {
  
  // @@protoc_insertion_point(field_mutable:build.tools.releasetools.PartitionState.partition_name)
  return partition_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionState::release_partition_name() {
  // @@protoc_insertion_point(field_release:build.tools.releasetools.PartitionState.partition_name)
  
  return partition_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionState::set_allocated_partition_name(::std::string* partition_name) {
  if (partition_name != nullptr) {
    
  } else {
    
  }
  partition_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), partition_name);
  // @@protoc_insertion_point(field_set_allocated:build.tools.releasetools.PartitionState.partition_name)
}

// repeated string device = 2;
inline int PartitionState::device_size() const {
  return device_.size();
}
inline void PartitionState::clear_device() {
  device_.Clear();
}
inline const ::std::string& PartitionState::device(int index) const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.PartitionState.device)
  return device_.Get(index);
}
inline ::std::string* PartitionState::mutable_device(int index) {
  // @@protoc_insertion_point(field_mutable:build.tools.releasetools.PartitionState.device)
  return device_.Mutable(index);
}
inline void PartitionState::set_device(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:build.tools.releasetools.PartitionState.device)
  device_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void PartitionState::set_device(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:build.tools.releasetools.PartitionState.device)
  device_.Mutable(index)->assign(std::move(value));
}
#endif
inline void PartitionState::set_device(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  device_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:build.tools.releasetools.PartitionState.device)
}
inline void PartitionState::set_device(int index, const char* value, size_t size) {
  device_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:build.tools.releasetools.PartitionState.device)
}
inline ::std::string* PartitionState::add_device() {
  // @@protoc_insertion_point(field_add_mutable:build.tools.releasetools.PartitionState.device)
  return device_.Add();
}
inline void PartitionState::add_device(const ::std::string& value) {
  device_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:build.tools.releasetools.PartitionState.device)
}
#if LANG_CXX11
inline void PartitionState::add_device(::std::string&& value) {
  device_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:build.tools.releasetools.PartitionState.device)
}
#endif
inline void PartitionState::add_device(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  device_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:build.tools.releasetools.PartitionState.device)
}
inline void PartitionState::add_device(const char* value, size_t size) {
  device_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:build.tools.releasetools.PartitionState.device)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
PartitionState::device() const {
  // @@protoc_insertion_point(field_list:build.tools.releasetools.PartitionState.device)
  return device_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
PartitionState::mutable_device() {
  // @@protoc_insertion_point(field_mutable_list:build.tools.releasetools.PartitionState.device)
  return &device_;
}

// repeated string build = 3;
inline int PartitionState::build_size() const {
  return build_.size();
}
inline void PartitionState::clear_build() {
  build_.Clear();
}
inline const ::std::string& PartitionState::build(int index) const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.PartitionState.build)
  return build_.Get(index);
}
inline ::std::string* PartitionState::mutable_build(int index) {
  // @@protoc_insertion_point(field_mutable:build.tools.releasetools.PartitionState.build)
  return build_.Mutable(index);
}
inline void PartitionState::set_build(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:build.tools.releasetools.PartitionState.build)
  build_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void PartitionState::set_build(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:build.tools.releasetools.PartitionState.build)
  build_.Mutable(index)->assign(std::move(value));
}
#endif
inline void PartitionState::set_build(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  build_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:build.tools.releasetools.PartitionState.build)
}
inline void PartitionState::set_build(int index, const char* value, size_t size) {
  build_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:build.tools.releasetools.PartitionState.build)
}
inline ::std::string* PartitionState::add_build() {
  // @@protoc_insertion_point(field_add_mutable:build.tools.releasetools.PartitionState.build)
  return build_.Add();
}
inline void PartitionState::add_build(const ::std::string& value) {
  build_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:build.tools.releasetools.PartitionState.build)
}
#if LANG_CXX11
inline void PartitionState::add_build(::std::string&& value) {
  build_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:build.tools.releasetools.PartitionState.build)
}
#endif
inline void PartitionState::add_build(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  build_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:build.tools.releasetools.PartitionState.build)
}
inline void PartitionState::add_build(const char* value, size_t size) {
  build_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:build.tools.releasetools.PartitionState.build)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
PartitionState::build() const {
  // @@protoc_insertion_point(field_list:build.tools.releasetools.PartitionState.build)
  return build_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
PartitionState::mutable_build() {
  // @@protoc_insertion_point(field_mutable_list:build.tools.releasetools.PartitionState.build)
  return &build_;
}

// string version = 4;
inline void PartitionState::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PartitionState::version() const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.PartitionState.version)
  return version_.GetNoArena();
}
inline void PartitionState::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:build.tools.releasetools.PartitionState.version)
}
#if LANG_CXX11
inline void PartitionState::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:build.tools.releasetools.PartitionState.version)
}
#endif
inline void PartitionState::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:build.tools.releasetools.PartitionState.version)
}
inline void PartitionState::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:build.tools.releasetools.PartitionState.version)
}
inline ::std::string* PartitionState::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:build.tools.releasetools.PartitionState.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionState::release_version() {
  // @@protoc_insertion_point(field_release:build.tools.releasetools.PartitionState.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionState::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:build.tools.releasetools.PartitionState.version)
}

// -------------------------------------------------------------------

// DeviceState

// repeated string device = 1;
inline int DeviceState::device_size() const {
  return device_.size();
}
inline void DeviceState::clear_device() {
  device_.Clear();
}
inline const ::std::string& DeviceState::device(int index) const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.DeviceState.device)
  return device_.Get(index);
}
inline ::std::string* DeviceState::mutable_device(int index) {
  // @@protoc_insertion_point(field_mutable:build.tools.releasetools.DeviceState.device)
  return device_.Mutable(index);
}
inline void DeviceState::set_device(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:build.tools.releasetools.DeviceState.device)
  device_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DeviceState::set_device(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:build.tools.releasetools.DeviceState.device)
  device_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DeviceState::set_device(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  device_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:build.tools.releasetools.DeviceState.device)
}
inline void DeviceState::set_device(int index, const char* value, size_t size) {
  device_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:build.tools.releasetools.DeviceState.device)
}
inline ::std::string* DeviceState::add_device() {
  // @@protoc_insertion_point(field_add_mutable:build.tools.releasetools.DeviceState.device)
  return device_.Add();
}
inline void DeviceState::add_device(const ::std::string& value) {
  device_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:build.tools.releasetools.DeviceState.device)
}
#if LANG_CXX11
inline void DeviceState::add_device(::std::string&& value) {
  device_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:build.tools.releasetools.DeviceState.device)
}
#endif
inline void DeviceState::add_device(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  device_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:build.tools.releasetools.DeviceState.device)
}
inline void DeviceState::add_device(const char* value, size_t size) {
  device_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:build.tools.releasetools.DeviceState.device)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
DeviceState::device() const {
  // @@protoc_insertion_point(field_list:build.tools.releasetools.DeviceState.device)
  return device_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
DeviceState::mutable_device() {
  // @@protoc_insertion_point(field_mutable_list:build.tools.releasetools.DeviceState.device)
  return &device_;
}

// repeated string build = 2;
inline int DeviceState::build_size() const {
  return build_.size();
}
inline void DeviceState::clear_build() {
  build_.Clear();
}
inline const ::std::string& DeviceState::build(int index) const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.DeviceState.build)
  return build_.Get(index);
}
inline ::std::string* DeviceState::mutable_build(int index) {
  // @@protoc_insertion_point(field_mutable:build.tools.releasetools.DeviceState.build)
  return build_.Mutable(index);
}
inline void DeviceState::set_build(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:build.tools.releasetools.DeviceState.build)
  build_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DeviceState::set_build(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:build.tools.releasetools.DeviceState.build)
  build_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DeviceState::set_build(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  build_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:build.tools.releasetools.DeviceState.build)
}
inline void DeviceState::set_build(int index, const char* value, size_t size) {
  build_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:build.tools.releasetools.DeviceState.build)
}
inline ::std::string* DeviceState::add_build() {
  // @@protoc_insertion_point(field_add_mutable:build.tools.releasetools.DeviceState.build)
  return build_.Add();
}
inline void DeviceState::add_build(const ::std::string& value) {
  build_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:build.tools.releasetools.DeviceState.build)
}
#if LANG_CXX11
inline void DeviceState::add_build(::std::string&& value) {
  build_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:build.tools.releasetools.DeviceState.build)
}
#endif
inline void DeviceState::add_build(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  build_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:build.tools.releasetools.DeviceState.build)
}
inline void DeviceState::add_build(const char* value, size_t size) {
  build_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:build.tools.releasetools.DeviceState.build)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
DeviceState::build() const {
  // @@protoc_insertion_point(field_list:build.tools.releasetools.DeviceState.build)
  return build_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
DeviceState::mutable_build() {
  // @@protoc_insertion_point(field_mutable_list:build.tools.releasetools.DeviceState.build)
  return &build_;
}

// string build_incremental = 3;
inline void DeviceState::clear_build_incremental() {
  build_incremental_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeviceState::build_incremental() const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.DeviceState.build_incremental)
  return build_incremental_.GetNoArena();
}
inline void DeviceState::set_build_incremental(const ::std::string& value) {
  
  build_incremental_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:build.tools.releasetools.DeviceState.build_incremental)
}
#if LANG_CXX11
inline void DeviceState::set_build_incremental(::std::string&& value) {
  
  build_incremental_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:build.tools.releasetools.DeviceState.build_incremental)
}
#endif
inline void DeviceState::set_build_incremental(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  build_incremental_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:build.tools.releasetools.DeviceState.build_incremental)
}
inline void DeviceState::set_build_incremental(const char* value, size_t size) {
  
  build_incremental_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:build.tools.releasetools.DeviceState.build_incremental)
}
inline ::std::string* DeviceState::mutable_build_incremental() {
  
  // @@protoc_insertion_point(field_mutable:build.tools.releasetools.DeviceState.build_incremental)
  return build_incremental_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceState::release_build_incremental() {
  // @@protoc_insertion_point(field_release:build.tools.releasetools.DeviceState.build_incremental)
  
  return build_incremental_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceState::set_allocated_build_incremental(::std::string* build_incremental) {
  if (build_incremental != nullptr) {
    
  } else {
    
  }
  build_incremental_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), build_incremental);
  // @@protoc_insertion_point(field_set_allocated:build.tools.releasetools.DeviceState.build_incremental)
}

// int64 timestamp = 4;
inline void DeviceState::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 DeviceState::timestamp() const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.DeviceState.timestamp)
  return timestamp_;
}
inline void DeviceState::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:build.tools.releasetools.DeviceState.timestamp)
}

// string sdk_level = 5;
inline void DeviceState::clear_sdk_level() {
  sdk_level_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeviceState::sdk_level() const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.DeviceState.sdk_level)
  return sdk_level_.GetNoArena();
}
inline void DeviceState::set_sdk_level(const ::std::string& value) {
  
  sdk_level_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:build.tools.releasetools.DeviceState.sdk_level)
}
#if LANG_CXX11
inline void DeviceState::set_sdk_level(::std::string&& value) {
  
  sdk_level_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:build.tools.releasetools.DeviceState.sdk_level)
}
#endif
inline void DeviceState::set_sdk_level(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sdk_level_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:build.tools.releasetools.DeviceState.sdk_level)
}
inline void DeviceState::set_sdk_level(const char* value, size_t size) {
  
  sdk_level_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:build.tools.releasetools.DeviceState.sdk_level)
}
inline ::std::string* DeviceState::mutable_sdk_level() {
  
  // @@protoc_insertion_point(field_mutable:build.tools.releasetools.DeviceState.sdk_level)
  return sdk_level_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceState::release_sdk_level() {
  // @@protoc_insertion_point(field_release:build.tools.releasetools.DeviceState.sdk_level)
  
  return sdk_level_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceState::set_allocated_sdk_level(::std::string* sdk_level) {
  if (sdk_level != nullptr) {
    
  } else {
    
  }
  sdk_level_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sdk_level);
  // @@protoc_insertion_point(field_set_allocated:build.tools.releasetools.DeviceState.sdk_level)
}

// string security_patch_level = 6;
inline void DeviceState::clear_security_patch_level() {
  security_patch_level_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeviceState::security_patch_level() const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.DeviceState.security_patch_level)
  return security_patch_level_.GetNoArena();
}
inline void DeviceState::set_security_patch_level(const ::std::string& value) {
  
  security_patch_level_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:build.tools.releasetools.DeviceState.security_patch_level)
}
#if LANG_CXX11
inline void DeviceState::set_security_patch_level(::std::string&& value) {
  
  security_patch_level_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:build.tools.releasetools.DeviceState.security_patch_level)
}
#endif
inline void DeviceState::set_security_patch_level(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  security_patch_level_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:build.tools.releasetools.DeviceState.security_patch_level)
}
inline void DeviceState::set_security_patch_level(const char* value, size_t size) {
  
  security_patch_level_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:build.tools.releasetools.DeviceState.security_patch_level)
}
inline ::std::string* DeviceState::mutable_security_patch_level() {
  
  // @@protoc_insertion_point(field_mutable:build.tools.releasetools.DeviceState.security_patch_level)
  return security_patch_level_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceState::release_security_patch_level() {
  // @@protoc_insertion_point(field_release:build.tools.releasetools.DeviceState.security_patch_level)
  
  return security_patch_level_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceState::set_allocated_security_patch_level(::std::string* security_patch_level) {
  if (security_patch_level != nullptr) {
    
  } else {
    
  }
  security_patch_level_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), security_patch_level);
  // @@protoc_insertion_point(field_set_allocated:build.tools.releasetools.DeviceState.security_patch_level)
}

// repeated .build.tools.releasetools.PartitionState partition_state = 7;
inline int DeviceState::partition_state_size() const {
  return partition_state_.size();
}
inline void DeviceState::clear_partition_state() {
  partition_state_.Clear();
}
inline ::build::tools::releasetools::PartitionState* DeviceState::mutable_partition_state(int index) {
  // @@protoc_insertion_point(field_mutable:build.tools.releasetools.DeviceState.partition_state)
  return partition_state_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::build::tools::releasetools::PartitionState >*
DeviceState::mutable_partition_state() {
  // @@protoc_insertion_point(field_mutable_list:build.tools.releasetools.DeviceState.partition_state)
  return &partition_state_;
}
inline const ::build::tools::releasetools::PartitionState& DeviceState::partition_state(int index) const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.DeviceState.partition_state)
  return partition_state_.Get(index);
}
inline ::build::tools::releasetools::PartitionState* DeviceState::add_partition_state() {
  // @@protoc_insertion_point(field_add:build.tools.releasetools.DeviceState.partition_state)
  return partition_state_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::build::tools::releasetools::PartitionState >&
DeviceState::partition_state() const {
  // @@protoc_insertion_point(field_list:build.tools.releasetools.DeviceState.partition_state)
  return partition_state_;
}

// -------------------------------------------------------------------

// ApexInfo

// string package_name = 1;
inline void ApexInfo::clear_package_name() {
  package_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ApexInfo::package_name() const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.ApexInfo.package_name)
  return package_name_.GetNoArena();
}
inline void ApexInfo::set_package_name(const ::std::string& value) {
  
  package_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:build.tools.releasetools.ApexInfo.package_name)
}
#if LANG_CXX11
inline void ApexInfo::set_package_name(::std::string&& value) {
  
  package_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:build.tools.releasetools.ApexInfo.package_name)
}
#endif
inline void ApexInfo::set_package_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  package_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:build.tools.releasetools.ApexInfo.package_name)
}
inline void ApexInfo::set_package_name(const char* value, size_t size) {
  
  package_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:build.tools.releasetools.ApexInfo.package_name)
}
inline ::std::string* ApexInfo::mutable_package_name() {
  
  // @@protoc_insertion_point(field_mutable:build.tools.releasetools.ApexInfo.package_name)
  return package_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApexInfo::release_package_name() {
  // @@protoc_insertion_point(field_release:build.tools.releasetools.ApexInfo.package_name)
  
  return package_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApexInfo::set_allocated_package_name(::std::string* package_name) {
  if (package_name != nullptr) {
    
  } else {
    
  }
  package_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), package_name);
  // @@protoc_insertion_point(field_set_allocated:build.tools.releasetools.ApexInfo.package_name)
}

// int64 version = 2;
inline void ApexInfo::clear_version() {
  version_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ApexInfo::version() const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.ApexInfo.version)
  return version_;
}
inline void ApexInfo::set_version(::google::protobuf::int64 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:build.tools.releasetools.ApexInfo.version)
}

// bool is_compressed = 3;
inline void ApexInfo::clear_is_compressed() {
  is_compressed_ = false;
}
inline bool ApexInfo::is_compressed() const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.ApexInfo.is_compressed)
  return is_compressed_;
}
inline void ApexInfo::set_is_compressed(bool value) {
  
  is_compressed_ = value;
  // @@protoc_insertion_point(field_set:build.tools.releasetools.ApexInfo.is_compressed)
}

// int64 decompressed_size = 4;
inline void ApexInfo::clear_decompressed_size() {
  decompressed_size_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ApexInfo::decompressed_size() const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.ApexInfo.decompressed_size)
  return decompressed_size_;
}
inline void ApexInfo::set_decompressed_size(::google::protobuf::int64 value) {
  
  decompressed_size_ = value;
  // @@protoc_insertion_point(field_set:build.tools.releasetools.ApexInfo.decompressed_size)
}

// int64 source_version = 5;
inline void ApexInfo::clear_source_version() {
  source_version_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ApexInfo::source_version() const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.ApexInfo.source_version)
  return source_version_;
}
inline void ApexInfo::set_source_version(::google::protobuf::int64 value) {
  
  source_version_ = value;
  // @@protoc_insertion_point(field_set:build.tools.releasetools.ApexInfo.source_version)
}

// -------------------------------------------------------------------

// ApexMetadata

// repeated .build.tools.releasetools.ApexInfo apex_info = 1;
inline int ApexMetadata::apex_info_size() const {
  return apex_info_.size();
}
inline void ApexMetadata::clear_apex_info() {
  apex_info_.Clear();
}
inline ::build::tools::releasetools::ApexInfo* ApexMetadata::mutable_apex_info(int index) {
  // @@protoc_insertion_point(field_mutable:build.tools.releasetools.ApexMetadata.apex_info)
  return apex_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::build::tools::releasetools::ApexInfo >*
ApexMetadata::mutable_apex_info() {
  // @@protoc_insertion_point(field_mutable_list:build.tools.releasetools.ApexMetadata.apex_info)
  return &apex_info_;
}
inline const ::build::tools::releasetools::ApexInfo& ApexMetadata::apex_info(int index) const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.ApexMetadata.apex_info)
  return apex_info_.Get(index);
}
inline ::build::tools::releasetools::ApexInfo* ApexMetadata::add_apex_info() {
  // @@protoc_insertion_point(field_add:build.tools.releasetools.ApexMetadata.apex_info)
  return apex_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::build::tools::releasetools::ApexInfo >&
ApexMetadata::apex_info() const {
  // @@protoc_insertion_point(field_list:build.tools.releasetools.ApexMetadata.apex_info)
  return apex_info_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// OtaMetadata

// .build.tools.releasetools.OtaMetadata.OtaType type = 1;
inline void OtaMetadata::clear_type() {
  type_ = 0;
}
inline ::build::tools::releasetools::OtaMetadata_OtaType OtaMetadata::type() const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.OtaMetadata.type)
  return static_cast< ::build::tools::releasetools::OtaMetadata_OtaType >(type_);
}
inline void OtaMetadata::set_type(::build::tools::releasetools::OtaMetadata_OtaType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:build.tools.releasetools.OtaMetadata.type)
}

// bool wipe = 2;
inline void OtaMetadata::clear_wipe() {
  wipe_ = false;
}
inline bool OtaMetadata::wipe() const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.OtaMetadata.wipe)
  return wipe_;
}
inline void OtaMetadata::set_wipe(bool value) {
  
  wipe_ = value;
  // @@protoc_insertion_point(field_set:build.tools.releasetools.OtaMetadata.wipe)
}

// bool downgrade = 3;
inline void OtaMetadata::clear_downgrade() {
  downgrade_ = false;
}
inline bool OtaMetadata::downgrade() const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.OtaMetadata.downgrade)
  return downgrade_;
}
inline void OtaMetadata::set_downgrade(bool value) {
  
  downgrade_ = value;
  // @@protoc_insertion_point(field_set:build.tools.releasetools.OtaMetadata.downgrade)
}

// map<string, string> property_files = 4;
inline int OtaMetadata::property_files_size() const {
  return property_files_.size();
}
inline void OtaMetadata::clear_property_files() {
  property_files_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
OtaMetadata::property_files() const {
  // @@protoc_insertion_point(field_map:build.tools.releasetools.OtaMetadata.property_files)
  return property_files_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
OtaMetadata::mutable_property_files() {
  // @@protoc_insertion_point(field_mutable_map:build.tools.releasetools.OtaMetadata.property_files)
  return property_files_.MutableMap();
}

// .build.tools.releasetools.DeviceState precondition = 5;
inline bool OtaMetadata::has_precondition() const {
  return this != internal_default_instance() && precondition_ != nullptr;
}
inline void OtaMetadata::clear_precondition() {
  if (GetArenaNoVirtual() == nullptr && precondition_ != nullptr) {
    delete precondition_;
  }
  precondition_ = nullptr;
}
inline const ::build::tools::releasetools::DeviceState& OtaMetadata::precondition() const {
  const ::build::tools::releasetools::DeviceState* p = precondition_;
  // @@protoc_insertion_point(field_get:build.tools.releasetools.OtaMetadata.precondition)
  return p != nullptr ? *p : *reinterpret_cast<const ::build::tools::releasetools::DeviceState*>(
      &::build::tools::releasetools::_DeviceState_default_instance_);
}
inline ::build::tools::releasetools::DeviceState* OtaMetadata::release_precondition() {
  // @@protoc_insertion_point(field_release:build.tools.releasetools.OtaMetadata.precondition)
  
  ::build::tools::releasetools::DeviceState* temp = precondition_;
  precondition_ = nullptr;
  return temp;
}
inline ::build::tools::releasetools::DeviceState* OtaMetadata::mutable_precondition() {
  
  if (precondition_ == nullptr) {
    auto* p = CreateMaybeMessage<::build::tools::releasetools::DeviceState>(GetArenaNoVirtual());
    precondition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:build.tools.releasetools.OtaMetadata.precondition)
  return precondition_;
}
inline void OtaMetadata::set_allocated_precondition(::build::tools::releasetools::DeviceState* precondition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete precondition_;
  }
  if (precondition) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      precondition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, precondition, submessage_arena);
    }
    
  } else {
    
  }
  precondition_ = precondition;
  // @@protoc_insertion_point(field_set_allocated:build.tools.releasetools.OtaMetadata.precondition)
}

// .build.tools.releasetools.DeviceState postcondition = 6;
inline bool OtaMetadata::has_postcondition() const {
  return this != internal_default_instance() && postcondition_ != nullptr;
}
inline void OtaMetadata::clear_postcondition() {
  if (GetArenaNoVirtual() == nullptr && postcondition_ != nullptr) {
    delete postcondition_;
  }
  postcondition_ = nullptr;
}
inline const ::build::tools::releasetools::DeviceState& OtaMetadata::postcondition() const {
  const ::build::tools::releasetools::DeviceState* p = postcondition_;
  // @@protoc_insertion_point(field_get:build.tools.releasetools.OtaMetadata.postcondition)
  return p != nullptr ? *p : *reinterpret_cast<const ::build::tools::releasetools::DeviceState*>(
      &::build::tools::releasetools::_DeviceState_default_instance_);
}
inline ::build::tools::releasetools::DeviceState* OtaMetadata::release_postcondition() {
  // @@protoc_insertion_point(field_release:build.tools.releasetools.OtaMetadata.postcondition)
  
  ::build::tools::releasetools::DeviceState* temp = postcondition_;
  postcondition_ = nullptr;
  return temp;
}
inline ::build::tools::releasetools::DeviceState* OtaMetadata::mutable_postcondition() {
  
  if (postcondition_ == nullptr) {
    auto* p = CreateMaybeMessage<::build::tools::releasetools::DeviceState>(GetArenaNoVirtual());
    postcondition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:build.tools.releasetools.OtaMetadata.postcondition)
  return postcondition_;
}
inline void OtaMetadata::set_allocated_postcondition(::build::tools::releasetools::DeviceState* postcondition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete postcondition_;
  }
  if (postcondition) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      postcondition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, postcondition, submessage_arena);
    }
    
  } else {
    
  }
  postcondition_ = postcondition;
  // @@protoc_insertion_point(field_set_allocated:build.tools.releasetools.OtaMetadata.postcondition)
}

// bool retrofit_dynamic_partitions = 7;
inline void OtaMetadata::clear_retrofit_dynamic_partitions() {
  retrofit_dynamic_partitions_ = false;
}
inline bool OtaMetadata::retrofit_dynamic_partitions() const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.OtaMetadata.retrofit_dynamic_partitions)
  return retrofit_dynamic_partitions_;
}
inline void OtaMetadata::set_retrofit_dynamic_partitions(bool value) {
  
  retrofit_dynamic_partitions_ = value;
  // @@protoc_insertion_point(field_set:build.tools.releasetools.OtaMetadata.retrofit_dynamic_partitions)
}

// int64 required_cache = 8;
inline void OtaMetadata::clear_required_cache() {
  required_cache_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 OtaMetadata::required_cache() const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.OtaMetadata.required_cache)
  return required_cache_;
}
inline void OtaMetadata::set_required_cache(::google::protobuf::int64 value) {
  
  required_cache_ = value;
  // @@protoc_insertion_point(field_set:build.tools.releasetools.OtaMetadata.required_cache)
}

// bool spl_downgrade = 9;
inline void OtaMetadata::clear_spl_downgrade() {
  spl_downgrade_ = false;
}
inline bool OtaMetadata::spl_downgrade() const {
  // @@protoc_insertion_point(field_get:build.tools.releasetools.OtaMetadata.spl_downgrade)
  return spl_downgrade_;
}
inline void OtaMetadata::set_spl_downgrade(bool value) {
  
  spl_downgrade_ = value;
  // @@protoc_insertion_point(field_set:build.tools.releasetools.OtaMetadata.spl_downgrade)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace releasetools
}  // namespace tools
}  // namespace build

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::build::tools::releasetools::OtaMetadata_OtaType> : ::std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_ota_5fmetadata_2eproto
