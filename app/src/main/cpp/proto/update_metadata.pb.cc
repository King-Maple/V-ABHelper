// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: update_metadata.proto

#include "update_metadata.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_update_5fmetadata_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ApexInfo_update_5fmetadata_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_update_5fmetadata_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_DynamicPartitionGroup_update_5fmetadata_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_update_5fmetadata_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Extent_update_5fmetadata_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_update_5fmetadata_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_PartitionInfo_update_5fmetadata_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_update_5fmetadata_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Signatures_Signature_update_5fmetadata_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_update_5fmetadata_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_VABCFeatureSet_update_5fmetadata_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_update_5fmetadata_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_CowMergeOperation_update_5fmetadata_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_update_5fmetadata_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_InstallOperation_update_5fmetadata_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_update_5fmetadata_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_DynamicPartitionMetadata_update_5fmetadata_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_update_5fmetadata_2eproto ::google::protobuf::internal::SCCInfo<5> scc_info_PartitionUpdate_update_5fmetadata_2eproto;
namespace chromeos_update_engine {
class ExtentDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Extent> _instance;
} _Extent_default_instance_;
class Signatures_SignatureDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Signatures_Signature> _instance;
} _Signatures_Signature_default_instance_;
class SignaturesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Signatures> _instance;
} _Signatures_default_instance_;
class PartitionInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<PartitionInfo> _instance;
} _PartitionInfo_default_instance_;
class InstallOperationDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<InstallOperation> _instance;
} _InstallOperation_default_instance_;
class CowMergeOperationDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<CowMergeOperation> _instance;
} _CowMergeOperation_default_instance_;
class PartitionUpdateDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<PartitionUpdate> _instance;
} _PartitionUpdate_default_instance_;
class DynamicPartitionGroupDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<DynamicPartitionGroup> _instance;
} _DynamicPartitionGroup_default_instance_;
class VABCFeatureSetDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<VABCFeatureSet> _instance;
} _VABCFeatureSet_default_instance_;
class DynamicPartitionMetadataDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<DynamicPartitionMetadata> _instance;
} _DynamicPartitionMetadata_default_instance_;
class ApexInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ApexInfo> _instance;
} _ApexInfo_default_instance_;
class ApexMetadataDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ApexMetadata> _instance;
} _ApexMetadata_default_instance_;
class DeltaArchiveManifestDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<DeltaArchiveManifest> _instance;
} _DeltaArchiveManifest_default_instance_;
}  // namespace chromeos_update_engine
static void InitDefaultsExtent_update_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_Extent_default_instance_;
    new (ptr) ::chromeos_update_engine::Extent();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::Extent::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Extent_update_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsExtent_update_5fmetadata_2eproto}, {}};

static void InitDefaultsSignatures_Signature_update_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_Signatures_Signature_default_instance_;
    new (ptr) ::chromeos_update_engine::Signatures_Signature();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::Signatures_Signature::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Signatures_Signature_update_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsSignatures_Signature_update_5fmetadata_2eproto}, {}};

static void InitDefaultsSignatures_update_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_Signatures_default_instance_;
    new (ptr) ::chromeos_update_engine::Signatures();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::Signatures::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Signatures_update_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsSignatures_update_5fmetadata_2eproto}, {
      &scc_info_Signatures_Signature_update_5fmetadata_2eproto.base,}};

static void InitDefaultsPartitionInfo_update_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_PartitionInfo_default_instance_;
    new (ptr) ::chromeos_update_engine::PartitionInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::PartitionInfo::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_PartitionInfo_update_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsPartitionInfo_update_5fmetadata_2eproto}, {}};

static void InitDefaultsInstallOperation_update_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_InstallOperation_default_instance_;
    new (ptr) ::chromeos_update_engine::InstallOperation();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::InstallOperation::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_InstallOperation_update_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsInstallOperation_update_5fmetadata_2eproto}, {
      &scc_info_Extent_update_5fmetadata_2eproto.base,}};

static void InitDefaultsCowMergeOperation_update_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_CowMergeOperation_default_instance_;
    new (ptr) ::chromeos_update_engine::CowMergeOperation();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::CowMergeOperation::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_CowMergeOperation_update_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsCowMergeOperation_update_5fmetadata_2eproto}, {
      &scc_info_Extent_update_5fmetadata_2eproto.base,}};

static void InitDefaultsPartitionUpdate_update_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_PartitionUpdate_default_instance_;
    new (ptr) ::chromeos_update_engine::PartitionUpdate();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::PartitionUpdate::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<5> scc_info_PartitionUpdate_update_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 5, InitDefaultsPartitionUpdate_update_5fmetadata_2eproto}, {
      &scc_info_Signatures_Signature_update_5fmetadata_2eproto.base,
      &scc_info_PartitionInfo_update_5fmetadata_2eproto.base,
      &scc_info_InstallOperation_update_5fmetadata_2eproto.base,
      &scc_info_Extent_update_5fmetadata_2eproto.base,
      &scc_info_CowMergeOperation_update_5fmetadata_2eproto.base,}};

static void InitDefaultsDynamicPartitionGroup_update_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_DynamicPartitionGroup_default_instance_;
    new (ptr) ::chromeos_update_engine::DynamicPartitionGroup();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::DynamicPartitionGroup::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_DynamicPartitionGroup_update_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsDynamicPartitionGroup_update_5fmetadata_2eproto}, {}};

static void InitDefaultsVABCFeatureSet_update_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_VABCFeatureSet_default_instance_;
    new (ptr) ::chromeos_update_engine::VABCFeatureSet();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::VABCFeatureSet::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_VABCFeatureSet_update_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsVABCFeatureSet_update_5fmetadata_2eproto}, {}};

static void InitDefaultsDynamicPartitionMetadata_update_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_DynamicPartitionMetadata_default_instance_;
    new (ptr) ::chromeos_update_engine::DynamicPartitionMetadata();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::DynamicPartitionMetadata::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_DynamicPartitionMetadata_update_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsDynamicPartitionMetadata_update_5fmetadata_2eproto}, {
      &scc_info_DynamicPartitionGroup_update_5fmetadata_2eproto.base,
      &scc_info_VABCFeatureSet_update_5fmetadata_2eproto.base,}};

static void InitDefaultsApexInfo_update_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_ApexInfo_default_instance_;
    new (ptr) ::chromeos_update_engine::ApexInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::ApexInfo::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_ApexInfo_update_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsApexInfo_update_5fmetadata_2eproto}, {}};

static void InitDefaultsApexMetadata_update_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_ApexMetadata_default_instance_;
    new (ptr) ::chromeos_update_engine::ApexMetadata();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::ApexMetadata::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_ApexMetadata_update_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsApexMetadata_update_5fmetadata_2eproto}, {
      &scc_info_ApexInfo_update_5fmetadata_2eproto.base,}};

static void InitDefaultsDeltaArchiveManifest_update_5fmetadata_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::chromeos_update_engine::_DeltaArchiveManifest_default_instance_;
    new (ptr) ::chromeos_update_engine::DeltaArchiveManifest();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::chromeos_update_engine::DeltaArchiveManifest::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<3> scc_info_DeltaArchiveManifest_update_5fmetadata_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsDeltaArchiveManifest_update_5fmetadata_2eproto}, {
      &scc_info_PartitionUpdate_update_5fmetadata_2eproto.base,
      &scc_info_DynamicPartitionMetadata_update_5fmetadata_2eproto.base,
      &scc_info_ApexInfo_update_5fmetadata_2eproto.base,}};

namespace chromeos_update_engine {
bool InstallOperation_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const InstallOperation_Type InstallOperation::REPLACE;
const InstallOperation_Type InstallOperation::REPLACE_BZ;
const InstallOperation_Type InstallOperation::MOVE;
const InstallOperation_Type InstallOperation::BSDIFF;
const InstallOperation_Type InstallOperation::SOURCE_COPY;
const InstallOperation_Type InstallOperation::SOURCE_BSDIFF;
const InstallOperation_Type InstallOperation::REPLACE_XZ;
const InstallOperation_Type InstallOperation::ZERO;
const InstallOperation_Type InstallOperation::DISCARD;
const InstallOperation_Type InstallOperation::BROTLI_BSDIFF;
const InstallOperation_Type InstallOperation::PUFFDIFF;
const InstallOperation_Type InstallOperation::ZUCCHINI;
const InstallOperation_Type InstallOperation::LZ4DIFF_BSDIFF;
const InstallOperation_Type InstallOperation::LZ4DIFF_PUFFDIFF;
const InstallOperation_Type InstallOperation::Type_MIN;
const InstallOperation_Type InstallOperation::Type_MAX;
const int InstallOperation::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool CowMergeOperation_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const CowMergeOperation_Type CowMergeOperation::COW_COPY;
const CowMergeOperation_Type CowMergeOperation::COW_XOR;
const CowMergeOperation_Type CowMergeOperation::COW_REPLACE;
const CowMergeOperation_Type CowMergeOperation::Type_MIN;
const CowMergeOperation_Type CowMergeOperation::Type_MAX;
const int CowMergeOperation::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

void Extent::InitAsDefaultInstance() {
}
class Extent::HasBitSetters {
 public:
  static void set_has_start_block(Extent* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_num_blocks(Extent* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Extent::kStartBlockFieldNumber;
const int Extent::kNumBlocksFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Extent::Extent()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.Extent)
}
Extent::Extent(const Extent& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&start_block_, &from.start_block_,
    static_cast<size_t>(reinterpret_cast<char*>(&num_blocks_) -
    reinterpret_cast<char*>(&start_block_)) + sizeof(num_blocks_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.Extent)
}

void Extent::SharedCtor() {
  ::memset(&start_block_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&num_blocks_) -
      reinterpret_cast<char*>(&start_block_)) + sizeof(num_blocks_));
}

Extent::~Extent() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.Extent)
  SharedDtor();
}

void Extent::SharedDtor() {
}

void Extent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Extent& Extent::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Extent_update_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void Extent::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.Extent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&start_block_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&num_blocks_) -
        reinterpret_cast<char*>(&start_block_)) + sizeof(num_blocks_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Extent::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Extent*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint64 start_block = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_start_block(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 num_blocks = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_num_blocks(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Extent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.Extent)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 start_block = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_start_block(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &start_block_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 num_blocks = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_num_blocks(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &num_blocks_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.Extent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.Extent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Extent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.Extent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 start_block = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->start_block(), output);
  }

  // optional uint64 num_blocks = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->num_blocks(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.Extent)
}

size_t Extent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.Extent)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 start_block = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->start_block());
    }

    // optional uint64 num_blocks = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->num_blocks());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Extent::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Extent*>(&from));
}

void Extent::MergeFrom(const Extent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.Extent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      start_block_ = from.start_block_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_blocks_ = from.num_blocks_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Extent::CopyFrom(const Extent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.Extent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Extent::IsInitialized() const {
  return true;
}

void Extent::Swap(Extent* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Extent::InternalSwap(Extent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(start_block_, other->start_block_);
  swap(num_blocks_, other->num_blocks_);
}

::std::string Extent::GetTypeName() const {
  return "chromeos_update_engine.Extent";
}


// ===================================================================

void Signatures_Signature::InitAsDefaultInstance() {
}
class Signatures_Signature::HasBitSetters {
 public:
  static void set_has_version(Signatures_Signature* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_data(Signatures_Signature* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_unpadded_signature_size(Signatures_Signature* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Signatures_Signature::kVersionFieldNumber;
const int Signatures_Signature::kDataFieldNumber;
const int Signatures_Signature::kUnpaddedSignatureSizeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Signatures_Signature::Signatures_Signature()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.Signatures.Signature)
}
Signatures_Signature::Signatures_Signature(const Signatures_Signature& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_data()) {
    data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
  }
  ::memcpy(&version_, &from.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&unpadded_signature_size_) -
    reinterpret_cast<char*>(&version_)) + sizeof(unpadded_signature_size_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.Signatures.Signature)
}

void Signatures_Signature::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Signatures_Signature_update_5fmetadata_2eproto.base);
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&unpadded_signature_size_) -
      reinterpret_cast<char*>(&version_)) + sizeof(unpadded_signature_size_));
}

Signatures_Signature::~Signatures_Signature() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.Signatures.Signature)
  SharedDtor();
}

void Signatures_Signature::SharedDtor() {
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Signatures_Signature::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Signatures_Signature& Signatures_Signature::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Signatures_Signature_update_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void Signatures_Signature::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.Signatures.Signature)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    data_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&unpadded_signature_size_) -
        reinterpret_cast<char*>(&version_)) + sizeof(unpadded_signature_size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Signatures_Signature::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Signatures_Signature*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint32 version = 1 [deprecated = true];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_version(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bytes data = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_data();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional fixed32 unpadded_signature_size = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        msg->set_unpadded_signature_size(::google::protobuf::io::UnalignedLoad<::google::protobuf::uint32>(ptr));
        ptr += sizeof(::google::protobuf::uint32);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Signatures_Signature::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.Signatures.Signature)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 version = 1 [deprecated = true];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_version(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes data = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional fixed32 unpadded_signature_size = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {
          HasBitSetters::set_has_unpadded_signature_size(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &unpadded_signature_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.Signatures.Signature)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.Signatures.Signature)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Signatures_Signature::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.Signatures.Signature)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 version = 1 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }

  // optional bytes data = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->data(), output);
  }

  // optional fixed32 unpadded_signature_size = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(3, this->unpadded_signature_size(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.Signatures.Signature)
}

size_t Signatures_Signature::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.Signatures.Signature)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional uint32 version = 1 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // optional fixed32 unpadded_signature_size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Signatures_Signature::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Signatures_Signature*>(&from));
}

void Signatures_Signature::MergeFrom(const Signatures_Signature& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.Signatures.Signature)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
    if (cached_has_bits & 0x00000002u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000004u) {
      unpadded_signature_size_ = from.unpadded_signature_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Signatures_Signature::CopyFrom(const Signatures_Signature& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.Signatures.Signature)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Signatures_Signature::IsInitialized() const {
  return true;
}

void Signatures_Signature::Swap(Signatures_Signature* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Signatures_Signature::InternalSwap(Signatures_Signature* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  data_.Swap(&other->data_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(version_, other->version_);
  swap(unpadded_signature_size_, other->unpadded_signature_size_);
}

::std::string Signatures_Signature::GetTypeName() const {
  return "chromeos_update_engine.Signatures.Signature";
}


// ===================================================================

void Signatures::InitAsDefaultInstance() {
}
class Signatures::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Signatures::kSignaturesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Signatures::Signatures()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.Signatures)
}
Signatures::Signatures(const Signatures& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      signatures_(from.signatures_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.Signatures)
}

void Signatures::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Signatures_update_5fmetadata_2eproto.base);
}

Signatures::~Signatures() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.Signatures)
  SharedDtor();
}

void Signatures::SharedDtor() {
}

void Signatures::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Signatures& Signatures::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Signatures_update_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void Signatures::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.Signatures)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  signatures_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Signatures::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Signatures*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::chromeos_update_engine::Signatures_Signature::_InternalParse;
          object = msg->add_signatures();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Signatures::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.Signatures)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_signatures()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.Signatures)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.Signatures)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Signatures::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.Signatures)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->signatures_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1,
      this->signatures(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.Signatures)
}

size_t Signatures::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.Signatures)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->signatures_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->signatures(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Signatures::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Signatures*>(&from));
}

void Signatures::MergeFrom(const Signatures& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.Signatures)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  signatures_.MergeFrom(from.signatures_);
}

void Signatures::CopyFrom(const Signatures& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.Signatures)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Signatures::IsInitialized() const {
  return true;
}

void Signatures::Swap(Signatures* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Signatures::InternalSwap(Signatures* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&signatures_)->InternalSwap(CastToBase(&other->signatures_));
}

::std::string Signatures::GetTypeName() const {
  return "chromeos_update_engine.Signatures";
}


// ===================================================================

void PartitionInfo::InitAsDefaultInstance() {
}
class PartitionInfo::HasBitSetters {
 public:
  static void set_has_size(PartitionInfo* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_hash(PartitionInfo* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PartitionInfo::kSizeFieldNumber;
const int PartitionInfo::kHashFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PartitionInfo::PartitionInfo()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.PartitionInfo)
}
PartitionInfo::PartitionInfo(const PartitionInfo& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_hash()) {
    hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hash_);
  }
  size_ = from.size_;
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.PartitionInfo)
}

void PartitionInfo::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_PartitionInfo_update_5fmetadata_2eproto.base);
  hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  size_ = PROTOBUF_ULONGLONG(0);
}

PartitionInfo::~PartitionInfo() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.PartitionInfo)
  SharedDtor();
}

void PartitionInfo::SharedDtor() {
  hash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void PartitionInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PartitionInfo& PartitionInfo::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_PartitionInfo_update_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void PartitionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.PartitionInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    hash_.ClearNonDefaultToEmptyNoArena();
  }
  size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PartitionInfo::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<PartitionInfo*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint64 size = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_size(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bytes hash = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_hash();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PartitionInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.PartitionInfo)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 size = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_size(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes hash = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.PartitionInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.PartitionInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PartitionInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.PartitionInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 size = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->size(), output);
  }

  // optional bytes hash = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->hash(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.PartitionInfo)
}

size_t PartitionInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.PartitionInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes hash = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->hash());
    }

    // optional uint64 size = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->size());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PartitionInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PartitionInfo*>(&from));
}

void PartitionInfo::MergeFrom(const PartitionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.PartitionInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hash_);
    }
    if (cached_has_bits & 0x00000002u) {
      size_ = from.size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PartitionInfo::CopyFrom(const PartitionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.PartitionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PartitionInfo::IsInitialized() const {
  return true;
}

void PartitionInfo::Swap(PartitionInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PartitionInfo::InternalSwap(PartitionInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  hash_.Swap(&other->hash_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(size_, other->size_);
}

::std::string PartitionInfo::GetTypeName() const {
  return "chromeos_update_engine.PartitionInfo";
}


// ===================================================================

void InstallOperation::InitAsDefaultInstance() {
}
class InstallOperation::HasBitSetters {
 public:
  static void set_has_type(InstallOperation* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_data_offset(InstallOperation* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_data_length(InstallOperation* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_src_length(InstallOperation* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static void set_has_dst_length(InstallOperation* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_data_sha256_hash(InstallOperation* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_src_sha256_hash(InstallOperation* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int InstallOperation::kTypeFieldNumber;
const int InstallOperation::kDataOffsetFieldNumber;
const int InstallOperation::kDataLengthFieldNumber;
const int InstallOperation::kSrcExtentsFieldNumber;
const int InstallOperation::kSrcLengthFieldNumber;
const int InstallOperation::kDstExtentsFieldNumber;
const int InstallOperation::kDstLengthFieldNumber;
const int InstallOperation::kDataSha256HashFieldNumber;
const int InstallOperation::kSrcSha256HashFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

InstallOperation::InstallOperation()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.InstallOperation)
}
InstallOperation::InstallOperation(const InstallOperation& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      src_extents_(from.src_extents_),
      dst_extents_(from.dst_extents_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  data_sha256_hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_data_sha256_hash()) {
    data_sha256_hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_sha256_hash_);
  }
  src_sha256_hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_src_sha256_hash()) {
    src_sha256_hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.src_sha256_hash_);
  }
  ::memcpy(&data_offset_, &from.data_offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&data_offset_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.InstallOperation)
}

void InstallOperation::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_InstallOperation_update_5fmetadata_2eproto.base);
  data_sha256_hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  src_sha256_hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&data_offset_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&data_offset_)) + sizeof(type_));
}

InstallOperation::~InstallOperation() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.InstallOperation)
  SharedDtor();
}

void InstallOperation::SharedDtor() {
  data_sha256_hash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  src_sha256_hash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void InstallOperation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const InstallOperation& InstallOperation::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_InstallOperation_update_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void InstallOperation::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.InstallOperation)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  src_extents_.Clear();
  dst_extents_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      data_sha256_hash_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      src_sha256_hash_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&data_offset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&type_) -
        reinterpret_cast<char*>(&data_offset_)) + sizeof(type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* InstallOperation::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<InstallOperation*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required .chromeos_update_engine.InstallOperation.Type type = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::chromeos_update_engine::InstallOperation_Type_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_type(static_cast<::chromeos_update_engine::InstallOperation_Type>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 data_offset = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_data_offset(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 data_length = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_data_length(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated .chromeos_update_engine.Extent src_extents = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::chromeos_update_engine::Extent::_InternalParse;
          object = msg->add_src_extents();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 34 && (ptr += 1));
        break;
      }
      // optional uint64 src_length = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_src_length(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated .chromeos_update_engine.Extent dst_extents = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::chromeos_update_engine::Extent::_InternalParse;
          object = msg->add_dst_extents();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 50 && (ptr += 1));
        break;
      }
      // optional uint64 dst_length = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        msg->set_dst_length(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bytes data_sha256_hash = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 66) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_data_sha256_hash();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bytes src_sha256_hash = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 74) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_src_sha256_hash();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool InstallOperation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.InstallOperation)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .chromeos_update_engine.InstallOperation.Type type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::chromeos_update_engine::InstallOperation_Type_IsValid(value)) {
            set_type(static_cast< ::chromeos_update_engine::InstallOperation_Type >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 data_offset = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_data_offset(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &data_offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 data_length = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_data_length(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &data_length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chromeos_update_engine.Extent src_extents = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_src_extents()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 src_length = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_src_length(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &src_length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chromeos_update_engine.Extent dst_extents = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_dst_extents()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 dst_length = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {
          HasBitSetters::set_has_dst_length(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dst_length_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes data_sha256_hash = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (66 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data_sha256_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes src_sha256_hash = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (74 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_src_sha256_hash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.InstallOperation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.InstallOperation)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void InstallOperation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.InstallOperation)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .chromeos_update_engine.InstallOperation.Type type = 1;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional uint64 data_offset = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->data_offset(), output);
  }

  // optional uint64 data_length = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->data_length(), output);
  }

  // repeated .chromeos_update_engine.Extent src_extents = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->src_extents_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4,
      this->src_extents(static_cast<int>(i)),
      output);
  }

  // optional uint64 src_length = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->src_length(), output);
  }

  // repeated .chromeos_update_engine.Extent dst_extents = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->dst_extents_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6,
      this->dst_extents(static_cast<int>(i)),
      output);
  }

  // optional uint64 dst_length = 7;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->dst_length(), output);
  }

  // optional bytes data_sha256_hash = 8;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      8, this->data_sha256_hash(), output);
  }

  // optional bytes src_sha256_hash = 9;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      9, this->src_sha256_hash(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.InstallOperation)
}

size_t InstallOperation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.InstallOperation)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required .chromeos_update_engine.InstallOperation.Type type = 1;
  if (has_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.Extent src_extents = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->src_extents_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->src_extents(static_cast<int>(i)));
    }
  }

  // repeated .chromeos_update_engine.Extent dst_extents = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->dst_extents_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->dst_extents(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes data_sha256_hash = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data_sha256_hash());
    }

    // optional bytes src_sha256_hash = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->src_sha256_hash());
    }

    // optional uint64 data_offset = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->data_offset());
    }

    // optional uint64 data_length = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->data_length());
    }

    // optional uint64 src_length = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->src_length());
    }

    // optional uint64 dst_length = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dst_length());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void InstallOperation::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const InstallOperation*>(&from));
}

void InstallOperation::MergeFrom(const InstallOperation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.InstallOperation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  src_extents_.MergeFrom(from.src_extents_);
  dst_extents_.MergeFrom(from.dst_extents_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      data_sha256_hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_sha256_hash_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      src_sha256_hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.src_sha256_hash_);
    }
    if (cached_has_bits & 0x00000004u) {
      data_offset_ = from.data_offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      data_length_ = from.data_length_;
    }
    if (cached_has_bits & 0x00000010u) {
      src_length_ = from.src_length_;
    }
    if (cached_has_bits & 0x00000020u) {
      dst_length_ = from.dst_length_;
    }
    if (cached_has_bits & 0x00000040u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void InstallOperation::CopyFrom(const InstallOperation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.InstallOperation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InstallOperation::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000040) != 0x00000040) return false;
  return true;
}

void InstallOperation::Swap(InstallOperation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void InstallOperation::InternalSwap(InstallOperation* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&src_extents_)->InternalSwap(CastToBase(&other->src_extents_));
  CastToBase(&dst_extents_)->InternalSwap(CastToBase(&other->dst_extents_));
  data_sha256_hash_.Swap(&other->data_sha256_hash_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  src_sha256_hash_.Swap(&other->src_sha256_hash_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(data_offset_, other->data_offset_);
  swap(data_length_, other->data_length_);
  swap(src_length_, other->src_length_);
  swap(dst_length_, other->dst_length_);
  swap(type_, other->type_);
}

::std::string InstallOperation::GetTypeName() const {
  return "chromeos_update_engine.InstallOperation";
}


// ===================================================================

void CowMergeOperation::InitAsDefaultInstance() {
  ::chromeos_update_engine::_CowMergeOperation_default_instance_._instance.get_mutable()->src_extent_ = const_cast< ::chromeos_update_engine::Extent*>(
      ::chromeos_update_engine::Extent::internal_default_instance());
  ::chromeos_update_engine::_CowMergeOperation_default_instance_._instance.get_mutable()->dst_extent_ = const_cast< ::chromeos_update_engine::Extent*>(
      ::chromeos_update_engine::Extent::internal_default_instance());
}
class CowMergeOperation::HasBitSetters {
 public:
  static void set_has_type(CowMergeOperation* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static const ::chromeos_update_engine::Extent& src_extent(const CowMergeOperation* msg);
  static void set_has_src_extent(CowMergeOperation* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static const ::chromeos_update_engine::Extent& dst_extent(const CowMergeOperation* msg);
  static void set_has_dst_extent(CowMergeOperation* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_src_offset(CowMergeOperation* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
};

const ::chromeos_update_engine::Extent&
CowMergeOperation::HasBitSetters::src_extent(const CowMergeOperation* msg) {
  return *msg->src_extent_;
}
const ::chromeos_update_engine::Extent&
CowMergeOperation::HasBitSetters::dst_extent(const CowMergeOperation* msg) {
  return *msg->dst_extent_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CowMergeOperation::kTypeFieldNumber;
const int CowMergeOperation::kSrcExtentFieldNumber;
const int CowMergeOperation::kDstExtentFieldNumber;
const int CowMergeOperation::kSrcOffsetFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CowMergeOperation::CowMergeOperation()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.CowMergeOperation)
}
CowMergeOperation::CowMergeOperation(const CowMergeOperation& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_src_extent()) {
    src_extent_ = new ::chromeos_update_engine::Extent(*from.src_extent_);
  } else {
    src_extent_ = nullptr;
  }
  if (from.has_dst_extent()) {
    dst_extent_ = new ::chromeos_update_engine::Extent(*from.dst_extent_);
  } else {
    dst_extent_ = nullptr;
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&src_offset_) -
    reinterpret_cast<char*>(&type_)) + sizeof(src_offset_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.CowMergeOperation)
}

void CowMergeOperation::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_CowMergeOperation_update_5fmetadata_2eproto.base);
  ::memset(&src_extent_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&src_offset_) -
      reinterpret_cast<char*>(&src_extent_)) + sizeof(src_offset_));
}

CowMergeOperation::~CowMergeOperation() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.CowMergeOperation)
  SharedDtor();
}

void CowMergeOperation::SharedDtor() {
  if (this != internal_default_instance()) delete src_extent_;
  if (this != internal_default_instance()) delete dst_extent_;
}

void CowMergeOperation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CowMergeOperation& CowMergeOperation::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_CowMergeOperation_update_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void CowMergeOperation::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.CowMergeOperation)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(src_extent_ != nullptr);
      src_extent_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(dst_extent_ != nullptr);
      dst_extent_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&src_offset_) -
        reinterpret_cast<char*>(&type_)) + sizeof(src_offset_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CowMergeOperation::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<CowMergeOperation*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val = ::google::protobuf::internal::ReadVarint(&ptr);
        if (!::chromeos_update_engine::CowMergeOperation_Type_IsValid(val)) {
          ::google::protobuf::internal::WriteVarint(1, val, msg->mutable_unknown_fields());
          break;
        }
        msg->set_type(static_cast<::chromeos_update_engine::CowMergeOperation_Type>(val));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .chromeos_update_engine.Extent src_extent = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::chromeos_update_engine::Extent::_InternalParse;
        object = msg->mutable_src_extent();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .chromeos_update_engine.Extent dst_extent = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::chromeos_update_engine::Extent::_InternalParse;
        object = msg->mutable_dst_extent();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint32 src_offset = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_src_offset(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CowMergeOperation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.CowMergeOperation)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::chromeos_update_engine::CowMergeOperation_Type_IsValid(value)) {
            set_type(static_cast< ::chromeos_update_engine::CowMergeOperation_Type >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast<::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.Extent src_extent = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_src_extent()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.Extent dst_extent = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_dst_extent()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 src_offset = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_src_offset(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &src_offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.CowMergeOperation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.CowMergeOperation)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CowMergeOperation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.CowMergeOperation)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .chromeos_update_engine.Extent src_extent = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, HasBitSetters::src_extent(this), output);
  }

  // optional .chromeos_update_engine.Extent dst_extent = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, HasBitSetters::dst_extent(this), output);
  }

  // optional uint32 src_offset = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->src_offset(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.CowMergeOperation)
}

size_t CowMergeOperation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.CowMergeOperation)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .chromeos_update_engine.Extent src_extent = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *src_extent_);
    }

    // optional .chromeos_update_engine.Extent dst_extent = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *dst_extent_);
    }

    // optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint32 src_offset = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->src_offset());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CowMergeOperation::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CowMergeOperation*>(&from));
}

void CowMergeOperation::MergeFrom(const CowMergeOperation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.CowMergeOperation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_src_extent()->::chromeos_update_engine::Extent::MergeFrom(from.src_extent());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_dst_extent()->::chromeos_update_engine::Extent::MergeFrom(from.dst_extent());
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      src_offset_ = from.src_offset_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CowMergeOperation::CopyFrom(const CowMergeOperation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.CowMergeOperation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CowMergeOperation::IsInitialized() const {
  return true;
}

void CowMergeOperation::Swap(CowMergeOperation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CowMergeOperation::InternalSwap(CowMergeOperation* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(src_extent_, other->src_extent_);
  swap(dst_extent_, other->dst_extent_);
  swap(type_, other->type_);
  swap(src_offset_, other->src_offset_);
}

::std::string CowMergeOperation::GetTypeName() const {
  return "chromeos_update_engine.CowMergeOperation";
}


// ===================================================================

void PartitionUpdate::InitAsDefaultInstance() {
  ::chromeos_update_engine::_PartitionUpdate_default_instance_._instance.get_mutable()->old_partition_info_ = const_cast< ::chromeos_update_engine::PartitionInfo*>(
      ::chromeos_update_engine::PartitionInfo::internal_default_instance());
  ::chromeos_update_engine::_PartitionUpdate_default_instance_._instance.get_mutable()->new_partition_info_ = const_cast< ::chromeos_update_engine::PartitionInfo*>(
      ::chromeos_update_engine::PartitionInfo::internal_default_instance());
  ::chromeos_update_engine::_PartitionUpdate_default_instance_._instance.get_mutable()->hash_tree_data_extent_ = const_cast< ::chromeos_update_engine::Extent*>(
      ::chromeos_update_engine::Extent::internal_default_instance());
  ::chromeos_update_engine::_PartitionUpdate_default_instance_._instance.get_mutable()->hash_tree_extent_ = const_cast< ::chromeos_update_engine::Extent*>(
      ::chromeos_update_engine::Extent::internal_default_instance());
  ::chromeos_update_engine::_PartitionUpdate_default_instance_._instance.get_mutable()->fec_data_extent_ = const_cast< ::chromeos_update_engine::Extent*>(
      ::chromeos_update_engine::Extent::internal_default_instance());
  ::chromeos_update_engine::_PartitionUpdate_default_instance_._instance.get_mutable()->fec_extent_ = const_cast< ::chromeos_update_engine::Extent*>(
      ::chromeos_update_engine::Extent::internal_default_instance());
}
class PartitionUpdate::HasBitSetters {
 public:
  static void set_has_partition_name(PartitionUpdate* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_run_postinstall(PartitionUpdate* msg) {
    msg->_has_bits_[0] |= 0x00002000u;
  }
  static void set_has_postinstall_path(PartitionUpdate* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_filesystem_type(PartitionUpdate* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static const ::chromeos_update_engine::PartitionInfo& old_partition_info(const PartitionUpdate* msg);
  static void set_has_old_partition_info(PartitionUpdate* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static const ::chromeos_update_engine::PartitionInfo& new_partition_info(const PartitionUpdate* msg);
  static void set_has_new_partition_info(PartitionUpdate* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_postinstall_optional(PartitionUpdate* msg) {
    msg->_has_bits_[0] |= 0x00004000u;
  }
  static const ::chromeos_update_engine::Extent& hash_tree_data_extent(const PartitionUpdate* msg);
  static void set_has_hash_tree_data_extent(PartitionUpdate* msg) {
    msg->_has_bits_[0] |= 0x00000100u;
  }
  static const ::chromeos_update_engine::Extent& hash_tree_extent(const PartitionUpdate* msg);
  static void set_has_hash_tree_extent(PartitionUpdate* msg) {
    msg->_has_bits_[0] |= 0x00000200u;
  }
  static void set_has_hash_tree_algorithm(PartitionUpdate* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_hash_tree_salt(PartitionUpdate* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static const ::chromeos_update_engine::Extent& fec_data_extent(const PartitionUpdate* msg);
  static void set_has_fec_data_extent(PartitionUpdate* msg) {
    msg->_has_bits_[0] |= 0x00000400u;
  }
  static const ::chromeos_update_engine::Extent& fec_extent(const PartitionUpdate* msg);
  static void set_has_fec_extent(PartitionUpdate* msg) {
    msg->_has_bits_[0] |= 0x00000800u;
  }
  static void set_has_fec_roots(PartitionUpdate* msg) {
    msg->_has_bits_[0] |= 0x00008000u;
  }
  static void set_has_version(PartitionUpdate* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_estimate_cow_size(PartitionUpdate* msg) {
    msg->_has_bits_[0] |= 0x00001000u;
  }
};

const ::chromeos_update_engine::PartitionInfo&
PartitionUpdate::HasBitSetters::old_partition_info(const PartitionUpdate* msg) {
  return *msg->old_partition_info_;
}
const ::chromeos_update_engine::PartitionInfo&
PartitionUpdate::HasBitSetters::new_partition_info(const PartitionUpdate* msg) {
  return *msg->new_partition_info_;
}
const ::chromeos_update_engine::Extent&
PartitionUpdate::HasBitSetters::hash_tree_data_extent(const PartitionUpdate* msg) {
  return *msg->hash_tree_data_extent_;
}
const ::chromeos_update_engine::Extent&
PartitionUpdate::HasBitSetters::hash_tree_extent(const PartitionUpdate* msg) {
  return *msg->hash_tree_extent_;
}
const ::chromeos_update_engine::Extent&
PartitionUpdate::HasBitSetters::fec_data_extent(const PartitionUpdate* msg) {
  return *msg->fec_data_extent_;
}
const ::chromeos_update_engine::Extent&
PartitionUpdate::HasBitSetters::fec_extent(const PartitionUpdate* msg) {
  return *msg->fec_extent_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PartitionUpdate::kPartitionNameFieldNumber;
const int PartitionUpdate::kRunPostinstallFieldNumber;
const int PartitionUpdate::kPostinstallPathFieldNumber;
const int PartitionUpdate::kFilesystemTypeFieldNumber;
const int PartitionUpdate::kNewPartitionSignatureFieldNumber;
const int PartitionUpdate::kOldPartitionInfoFieldNumber;
const int PartitionUpdate::kNewPartitionInfoFieldNumber;
const int PartitionUpdate::kOperationsFieldNumber;
const int PartitionUpdate::kPostinstallOptionalFieldNumber;
const int PartitionUpdate::kHashTreeDataExtentFieldNumber;
const int PartitionUpdate::kHashTreeExtentFieldNumber;
const int PartitionUpdate::kHashTreeAlgorithmFieldNumber;
const int PartitionUpdate::kHashTreeSaltFieldNumber;
const int PartitionUpdate::kFecDataExtentFieldNumber;
const int PartitionUpdate::kFecExtentFieldNumber;
const int PartitionUpdate::kFecRootsFieldNumber;
const int PartitionUpdate::kVersionFieldNumber;
const int PartitionUpdate::kMergeOperationsFieldNumber;
const int PartitionUpdate::kEstimateCowSizeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PartitionUpdate::PartitionUpdate()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.PartitionUpdate)
}
PartitionUpdate::PartitionUpdate(const PartitionUpdate& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      new_partition_signature_(from.new_partition_signature_),
      operations_(from.operations_),
      merge_operations_(from.merge_operations_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  partition_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_partition_name()) {
    partition_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.partition_name_);
  }
  postinstall_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_postinstall_path()) {
    postinstall_path_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.postinstall_path_);
  }
  filesystem_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_filesystem_type()) {
    filesystem_type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.filesystem_type_);
  }
  hash_tree_algorithm_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_hash_tree_algorithm()) {
    hash_tree_algorithm_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hash_tree_algorithm_);
  }
  hash_tree_salt_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_hash_tree_salt()) {
    hash_tree_salt_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hash_tree_salt_);
  }
  version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_version()) {
    version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.version_);
  }
  if (from.has_old_partition_info()) {
    old_partition_info_ = new ::chromeos_update_engine::PartitionInfo(*from.old_partition_info_);
  } else {
    old_partition_info_ = nullptr;
  }
  if (from.has_new_partition_info()) {
    new_partition_info_ = new ::chromeos_update_engine::PartitionInfo(*from.new_partition_info_);
  } else {
    new_partition_info_ = nullptr;
  }
  if (from.has_hash_tree_data_extent()) {
    hash_tree_data_extent_ = new ::chromeos_update_engine::Extent(*from.hash_tree_data_extent_);
  } else {
    hash_tree_data_extent_ = nullptr;
  }
  if (from.has_hash_tree_extent()) {
    hash_tree_extent_ = new ::chromeos_update_engine::Extent(*from.hash_tree_extent_);
  } else {
    hash_tree_extent_ = nullptr;
  }
  if (from.has_fec_data_extent()) {
    fec_data_extent_ = new ::chromeos_update_engine::Extent(*from.fec_data_extent_);
  } else {
    fec_data_extent_ = nullptr;
  }
  if (from.has_fec_extent()) {
    fec_extent_ = new ::chromeos_update_engine::Extent(*from.fec_extent_);
  } else {
    fec_extent_ = nullptr;
  }
  ::memcpy(&estimate_cow_size_, &from.estimate_cow_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&fec_roots_) -
    reinterpret_cast<char*>(&estimate_cow_size_)) + sizeof(fec_roots_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.PartitionUpdate)
}

void PartitionUpdate::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_PartitionUpdate_update_5fmetadata_2eproto.base);
  partition_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  postinstall_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  filesystem_type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hash_tree_algorithm_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hash_tree_salt_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&old_partition_info_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&postinstall_optional_) -
      reinterpret_cast<char*>(&old_partition_info_)) + sizeof(postinstall_optional_));
  fec_roots_ = 2u;
}

PartitionUpdate::~PartitionUpdate() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.PartitionUpdate)
  SharedDtor();
}

void PartitionUpdate::SharedDtor() {
  partition_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  postinstall_path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  filesystem_type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hash_tree_algorithm_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hash_tree_salt_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete old_partition_info_;
  if (this != internal_default_instance()) delete new_partition_info_;
  if (this != internal_default_instance()) delete hash_tree_data_extent_;
  if (this != internal_default_instance()) delete hash_tree_extent_;
  if (this != internal_default_instance()) delete fec_data_extent_;
  if (this != internal_default_instance()) delete fec_extent_;
}

void PartitionUpdate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PartitionUpdate& PartitionUpdate::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_PartitionUpdate_update_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void PartitionUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.PartitionUpdate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  new_partition_signature_.Clear();
  operations_.Clear();
  merge_operations_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      partition_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      postinstall_path_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      filesystem_type_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      hash_tree_algorithm_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      hash_tree_salt_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000020u) {
      version_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(old_partition_info_ != nullptr);
      old_partition_info_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(new_partition_info_ != nullptr);
      new_partition_info_->Clear();
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(hash_tree_data_extent_ != nullptr);
      hash_tree_data_extent_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(hash_tree_extent_ != nullptr);
      hash_tree_extent_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(fec_data_extent_ != nullptr);
      fec_data_extent_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(fec_extent_ != nullptr);
      fec_extent_->Clear();
    }
  }
  if (cached_has_bits & 0x0000f000u) {
    ::memset(&estimate_cow_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&postinstall_optional_) -
        reinterpret_cast<char*>(&estimate_cow_size_)) + sizeof(postinstall_optional_));
    fec_roots_ = 2u;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PartitionUpdate::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<PartitionUpdate*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required string partition_name = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_partition_name();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bool run_postinstall = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_run_postinstall(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional string postinstall_path = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_postinstall_path();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional string filesystem_type = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_filesystem_type();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::chromeos_update_engine::Signatures_Signature::_InternalParse;
          object = msg->add_new_partition_signature();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 42 && (ptr += 1));
        break;
      }
      // optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::chromeos_update_engine::PartitionInfo::_InternalParse;
        object = msg->mutable_old_partition_info();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 58) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::chromeos_update_engine::PartitionInfo::_InternalParse;
        object = msg->mutable_new_partition_info();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // repeated .chromeos_update_engine.InstallOperation operations = 8;
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 66) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::chromeos_update_engine::InstallOperation::_InternalParse;
          object = msg->add_operations();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 66 && (ptr += 1));
        break;
      }
      // optional bool postinstall_optional = 9;
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 72) goto handle_unusual;
        msg->set_postinstall_optional(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 82) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::chromeos_update_engine::Extent::_InternalParse;
        object = msg->mutable_hash_tree_data_extent();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .chromeos_update_engine.Extent hash_tree_extent = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 90) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::chromeos_update_engine::Extent::_InternalParse;
        object = msg->mutable_hash_tree_extent();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional string hash_tree_algorithm = 12;
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 98) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_hash_tree_algorithm();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional bytes hash_tree_salt = 13;
      case 13: {
        if (static_cast<::google::protobuf::uint8>(tag) != 106) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_hash_tree_salt();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional .chromeos_update_engine.Extent fec_data_extent = 14;
      case 14: {
        if (static_cast<::google::protobuf::uint8>(tag) != 114) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::chromeos_update_engine::Extent::_InternalParse;
        object = msg->mutable_fec_data_extent();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional .chromeos_update_engine.Extent fec_extent = 15;
      case 15: {
        if (static_cast<::google::protobuf::uint8>(tag) != 122) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::chromeos_update_engine::Extent::_InternalParse;
        object = msg->mutable_fec_extent();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional uint32 fec_roots = 16 [default = 2];
      case 16: {
        if (static_cast<::google::protobuf::uint8>(tag) != 128) goto handle_unusual;
        msg->set_fec_roots(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional string version = 17;
      case 17: {
        if (static_cast<::google::protobuf::uint8>(tag) != 138) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_version();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
      case 18: {
        if (static_cast<::google::protobuf::uint8>(tag) != 146) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::chromeos_update_engine::CowMergeOperation::_InternalParse;
          object = msg->add_merge_operations();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 65535) == 402 && (ptr += 2));
        break;
      }
      // optional uint64 estimate_cow_size = 19;
      case 19: {
        if (static_cast<::google::protobuf::uint8>(tag) != 152) goto handle_unusual;
        msg->set_estimate_cow_size(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PartitionUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.PartitionUpdate)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string partition_name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_partition_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool run_postinstall = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_run_postinstall(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &run_postinstall_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string postinstall_path = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_postinstall_path()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string filesystem_type = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filesystem_type()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_new_partition_signature()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_old_partition_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (58 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_new_partition_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chromeos_update_engine.InstallOperation operations = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (66 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_operations()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool postinstall_optional = 9;
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (72 & 0xFF)) {
          HasBitSetters::set_has_postinstall_optional(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &postinstall_optional_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (82 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_hash_tree_data_extent()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.Extent hash_tree_extent = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (90 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_hash_tree_extent()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string hash_tree_algorithm = 12;
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (98 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hash_tree_algorithm()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes hash_tree_salt = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (106 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hash_tree_salt()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.Extent fec_data_extent = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (114 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_fec_data_extent()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.Extent fec_extent = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (122 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_fec_extent()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 fec_roots = 16 [default = 2];
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (128 & 0xFF)) {
          HasBitSetters::set_has_fec_roots(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fec_roots_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string version = 17;
      case 17: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (138 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
      case 18: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (146 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_merge_operations()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 estimate_cow_size = 19;
      case 19: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (152 & 0xFF)) {
          HasBitSetters::set_has_estimate_cow_size(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &estimate_cow_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.PartitionUpdate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.PartitionUpdate)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PartitionUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.PartitionUpdate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string partition_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->partition_name(), output);
  }

  // optional bool run_postinstall = 2;
  if (cached_has_bits & 0x00002000u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->run_postinstall(), output);
  }

  // optional string postinstall_path = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->postinstall_path(), output);
  }

  // optional string filesystem_type = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->filesystem_type(), output);
  }

  // repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->new_partition_signature_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5,
      this->new_partition_signature(static_cast<int>(i)),
      output);
  }

  // optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, HasBitSetters::old_partition_info(this), output);
  }

  // optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, HasBitSetters::new_partition_info(this), output);
  }

  // repeated .chromeos_update_engine.InstallOperation operations = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->operations_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8,
      this->operations(static_cast<int>(i)),
      output);
  }

  // optional bool postinstall_optional = 9;
  if (cached_has_bits & 0x00004000u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->postinstall_optional(), output);
  }

  // optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, HasBitSetters::hash_tree_data_extent(this), output);
  }

  // optional .chromeos_update_engine.Extent hash_tree_extent = 11;
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, HasBitSetters::hash_tree_extent(this), output);
  }

  // optional string hash_tree_algorithm = 12;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      12, this->hash_tree_algorithm(), output);
  }

  // optional bytes hash_tree_salt = 13;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      13, this->hash_tree_salt(), output);
  }

  // optional .chromeos_update_engine.Extent fec_data_extent = 14;
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      14, HasBitSetters::fec_data_extent(this), output);
  }

  // optional .chromeos_update_engine.Extent fec_extent = 15;
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      15, HasBitSetters::fec_extent(this), output);
  }

  // optional uint32 fec_roots = 16 [default = 2];
  if (cached_has_bits & 0x00008000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(16, this->fec_roots(), output);
  }

  // optional string version = 17;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      17, this->version(), output);
  }

  // repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->merge_operations_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      18,
      this->merge_operations(static_cast<int>(i)),
      output);
  }

  // optional uint64 estimate_cow_size = 19;
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(19, this->estimate_cow_size(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.PartitionUpdate)
}

size_t PartitionUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.PartitionUpdate)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required string partition_name = 1;
  if (has_partition_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->partition_name());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->new_partition_signature_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->new_partition_signature(static_cast<int>(i)));
    }
  }

  // repeated .chromeos_update_engine.InstallOperation operations = 8;
  {
    unsigned int count = static_cast<unsigned int>(this->operations_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->operations(static_cast<int>(i)));
    }
  }

  // repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
  {
    unsigned int count = static_cast<unsigned int>(this->merge_operations_size());
    total_size += 2UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->merge_operations(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional string postinstall_path = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->postinstall_path());
    }

    // optional string filesystem_type = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filesystem_type());
    }

    // optional string hash_tree_algorithm = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hash_tree_algorithm());
    }

    // optional bytes hash_tree_salt = 13;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->hash_tree_salt());
    }

    // optional string version = 17;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *old_partition_info_);
    }

    // optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *new_partition_info_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *hash_tree_data_extent_);
    }

    // optional .chromeos_update_engine.Extent hash_tree_extent = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *hash_tree_extent_);
    }

    // optional .chromeos_update_engine.Extent fec_data_extent = 14;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *fec_data_extent_);
    }

    // optional .chromeos_update_engine.Extent fec_extent = 15;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *fec_extent_);
    }

    // optional uint64 estimate_cow_size = 19;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->estimate_cow_size());
    }

    // optional bool run_postinstall = 2;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool postinstall_optional = 9;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional uint32 fec_roots = 16 [default = 2];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fec_roots());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PartitionUpdate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PartitionUpdate*>(&from));
}

void PartitionUpdate::MergeFrom(const PartitionUpdate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.PartitionUpdate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  new_partition_signature_.MergeFrom(from.new_partition_signature_);
  operations_.MergeFrom(from.operations_);
  merge_operations_.MergeFrom(from.merge_operations_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      partition_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.partition_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      postinstall_path_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.postinstall_path_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      filesystem_type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.filesystem_type_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      hash_tree_algorithm_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hash_tree_algorithm_);
    }
    if (cached_has_bits & 0x00000010u) {
      _has_bits_[0] |= 0x00000010u;
      hash_tree_salt_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hash_tree_salt_);
    }
    if (cached_has_bits & 0x00000020u) {
      _has_bits_[0] |= 0x00000020u;
      version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.version_);
    }
    if (cached_has_bits & 0x00000040u) {
      mutable_old_partition_info()->::chromeos_update_engine::PartitionInfo::MergeFrom(from.old_partition_info());
    }
    if (cached_has_bits & 0x00000080u) {
      mutable_new_partition_info()->::chromeos_update_engine::PartitionInfo::MergeFrom(from.new_partition_info());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      mutable_hash_tree_data_extent()->::chromeos_update_engine::Extent::MergeFrom(from.hash_tree_data_extent());
    }
    if (cached_has_bits & 0x00000200u) {
      mutable_hash_tree_extent()->::chromeos_update_engine::Extent::MergeFrom(from.hash_tree_extent());
    }
    if (cached_has_bits & 0x00000400u) {
      mutable_fec_data_extent()->::chromeos_update_engine::Extent::MergeFrom(from.fec_data_extent());
    }
    if (cached_has_bits & 0x00000800u) {
      mutable_fec_extent()->::chromeos_update_engine::Extent::MergeFrom(from.fec_extent());
    }
    if (cached_has_bits & 0x00001000u) {
      estimate_cow_size_ = from.estimate_cow_size_;
    }
    if (cached_has_bits & 0x00002000u) {
      run_postinstall_ = from.run_postinstall_;
    }
    if (cached_has_bits & 0x00004000u) {
      postinstall_optional_ = from.postinstall_optional_;
    }
    if (cached_has_bits & 0x00008000u) {
      fec_roots_ = from.fec_roots_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PartitionUpdate::CopyFrom(const PartitionUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.PartitionUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PartitionUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->operations())) return false;
  return true;
}

void PartitionUpdate::Swap(PartitionUpdate* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PartitionUpdate::InternalSwap(PartitionUpdate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&new_partition_signature_)->InternalSwap(CastToBase(&other->new_partition_signature_));
  CastToBase(&operations_)->InternalSwap(CastToBase(&other->operations_));
  CastToBase(&merge_operations_)->InternalSwap(CastToBase(&other->merge_operations_));
  partition_name_.Swap(&other->partition_name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  postinstall_path_.Swap(&other->postinstall_path_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  filesystem_type_.Swap(&other->filesystem_type_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  hash_tree_algorithm_.Swap(&other->hash_tree_algorithm_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  hash_tree_salt_.Swap(&other->hash_tree_salt_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  version_.Swap(&other->version_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(old_partition_info_, other->old_partition_info_);
  swap(new_partition_info_, other->new_partition_info_);
  swap(hash_tree_data_extent_, other->hash_tree_data_extent_);
  swap(hash_tree_extent_, other->hash_tree_extent_);
  swap(fec_data_extent_, other->fec_data_extent_);
  swap(fec_extent_, other->fec_extent_);
  swap(estimate_cow_size_, other->estimate_cow_size_);
  swap(run_postinstall_, other->run_postinstall_);
  swap(postinstall_optional_, other->postinstall_optional_);
  swap(fec_roots_, other->fec_roots_);
}

::std::string PartitionUpdate::GetTypeName() const {
  return "chromeos_update_engine.PartitionUpdate";
}


// ===================================================================

void DynamicPartitionGroup::InitAsDefaultInstance() {
}
class DynamicPartitionGroup::HasBitSetters {
 public:
  static void set_has_name(DynamicPartitionGroup* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_size(DynamicPartitionGroup* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DynamicPartitionGroup::kNameFieldNumber;
const int DynamicPartitionGroup::kSizeFieldNumber;
const int DynamicPartitionGroup::kPartitionNamesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DynamicPartitionGroup::DynamicPartitionGroup()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.DynamicPartitionGroup)
}
DynamicPartitionGroup::DynamicPartitionGroup(const DynamicPartitionGroup& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      partition_names_(from.partition_names_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  size_ = from.size_;
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.DynamicPartitionGroup)
}

void DynamicPartitionGroup::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_DynamicPartitionGroup_update_5fmetadata_2eproto.base);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  size_ = PROTOBUF_ULONGLONG(0);
}

DynamicPartitionGroup::~DynamicPartitionGroup() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.DynamicPartitionGroup)
  SharedDtor();
}

void DynamicPartitionGroup::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void DynamicPartitionGroup::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DynamicPartitionGroup& DynamicPartitionGroup::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_DynamicPartitionGroup_update_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void DynamicPartitionGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.DynamicPartitionGroup)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  partition_names_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmptyNoArena();
  }
  size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* DynamicPartitionGroup::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<DynamicPartitionGroup*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // required string name = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_name();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint64 size = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_size(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated string partition_names = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          object = msg->add_partition_names();
          if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
            parser_till_end = ::google::protobuf::internal::GreedyStringParser;
            goto string_till_end;
          }
          GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
          ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
          ptr += size;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 26 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool DynamicPartitionGroup::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.DynamicPartitionGroup)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 size = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_size(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated string partition_names = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_partition_names()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.DynamicPartitionGroup)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.DynamicPartitionGroup)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void DynamicPartitionGroup::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.DynamicPartitionGroup)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional uint64 size = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->size(), output);
  }

  // repeated string partition_names = 3;
  for (int i = 0, n = this->partition_names_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->partition_names(i), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.DynamicPartitionGroup)
}

size_t DynamicPartitionGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.DynamicPartitionGroup)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required string name = 1;
  if (has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string partition_names = 3;
  total_size += 1 *
      ::google::protobuf::internal::FromIntSize(this->partition_names_size());
  for (int i = 0, n = this->partition_names_size(); i < n; i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->partition_names(i));
  }

  // optional uint64 size = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->size());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DynamicPartitionGroup::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DynamicPartitionGroup*>(&from));
}

void DynamicPartitionGroup::MergeFrom(const DynamicPartitionGroup& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.DynamicPartitionGroup)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  partition_names_.MergeFrom(from.partition_names_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      size_ = from.size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DynamicPartitionGroup::CopyFrom(const DynamicPartitionGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.DynamicPartitionGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DynamicPartitionGroup::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void DynamicPartitionGroup::Swap(DynamicPartitionGroup* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DynamicPartitionGroup::InternalSwap(DynamicPartitionGroup* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  partition_names_.InternalSwap(CastToBase(&other->partition_names_));
  name_.Swap(&other->name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(size_, other->size_);
}

::std::string DynamicPartitionGroup::GetTypeName() const {
  return "chromeos_update_engine.DynamicPartitionGroup";
}


// ===================================================================

void VABCFeatureSet::InitAsDefaultInstance() {
}
class VABCFeatureSet::HasBitSetters {
 public:
  static void set_has_threaded(VABCFeatureSet* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_batch_writes(VABCFeatureSet* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VABCFeatureSet::kThreadedFieldNumber;
const int VABCFeatureSet::kBatchWritesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VABCFeatureSet::VABCFeatureSet()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.VABCFeatureSet)
}
VABCFeatureSet::VABCFeatureSet(const VABCFeatureSet& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&threaded_, &from.threaded_,
    static_cast<size_t>(reinterpret_cast<char*>(&batch_writes_) -
    reinterpret_cast<char*>(&threaded_)) + sizeof(batch_writes_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.VABCFeatureSet)
}

void VABCFeatureSet::SharedCtor() {
  ::memset(&threaded_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&batch_writes_) -
      reinterpret_cast<char*>(&threaded_)) + sizeof(batch_writes_));
}

VABCFeatureSet::~VABCFeatureSet() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.VABCFeatureSet)
  SharedDtor();
}

void VABCFeatureSet::SharedDtor() {
}

void VABCFeatureSet::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const VABCFeatureSet& VABCFeatureSet::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_VABCFeatureSet_update_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void VABCFeatureSet::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.VABCFeatureSet)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&threaded_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&batch_writes_) -
      reinterpret_cast<char*>(&threaded_)) + sizeof(batch_writes_));
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* VABCFeatureSet::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<VABCFeatureSet*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional bool threaded = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        msg->set_threaded(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool batch_writes = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_batch_writes(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool VABCFeatureSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.VABCFeatureSet)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool threaded = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          HasBitSetters::set_has_threaded(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &threaded_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool batch_writes = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_batch_writes(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &batch_writes_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.VABCFeatureSet)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.VABCFeatureSet)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void VABCFeatureSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.VABCFeatureSet)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool threaded = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->threaded(), output);
  }

  // optional bool batch_writes = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->batch_writes(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.VABCFeatureSet)
}

size_t VABCFeatureSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.VABCFeatureSet)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool threaded = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool batch_writes = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VABCFeatureSet::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VABCFeatureSet*>(&from));
}

void VABCFeatureSet::MergeFrom(const VABCFeatureSet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.VABCFeatureSet)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      threaded_ = from.threaded_;
    }
    if (cached_has_bits & 0x00000002u) {
      batch_writes_ = from.batch_writes_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void VABCFeatureSet::CopyFrom(const VABCFeatureSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.VABCFeatureSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VABCFeatureSet::IsInitialized() const {
  return true;
}

void VABCFeatureSet::Swap(VABCFeatureSet* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VABCFeatureSet::InternalSwap(VABCFeatureSet* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(threaded_, other->threaded_);
  swap(batch_writes_, other->batch_writes_);
}

::std::string VABCFeatureSet::GetTypeName() const {
  return "chromeos_update_engine.VABCFeatureSet";
}


// ===================================================================

void DynamicPartitionMetadata::InitAsDefaultInstance() {
  ::chromeos_update_engine::_DynamicPartitionMetadata_default_instance_._instance.get_mutable()->vabc_feature_set_ = const_cast< ::chromeos_update_engine::VABCFeatureSet*>(
      ::chromeos_update_engine::VABCFeatureSet::internal_default_instance());
}
class DynamicPartitionMetadata::HasBitSetters {
 public:
  static void set_has_snapshot_enabled(DynamicPartitionMetadata* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_vabc_enabled(DynamicPartitionMetadata* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_vabc_compression_param(DynamicPartitionMetadata* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_cow_version(DynamicPartitionMetadata* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static const ::chromeos_update_engine::VABCFeatureSet& vabc_feature_set(const DynamicPartitionMetadata* msg);
  static void set_has_vabc_feature_set(DynamicPartitionMetadata* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
};

const ::chromeos_update_engine::VABCFeatureSet&
DynamicPartitionMetadata::HasBitSetters::vabc_feature_set(const DynamicPartitionMetadata* msg) {
  return *msg->vabc_feature_set_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DynamicPartitionMetadata::kGroupsFieldNumber;
const int DynamicPartitionMetadata::kSnapshotEnabledFieldNumber;
const int DynamicPartitionMetadata::kVabcEnabledFieldNumber;
const int DynamicPartitionMetadata::kVabcCompressionParamFieldNumber;
const int DynamicPartitionMetadata::kCowVersionFieldNumber;
const int DynamicPartitionMetadata::kVabcFeatureSetFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DynamicPartitionMetadata::DynamicPartitionMetadata()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.DynamicPartitionMetadata)
}
DynamicPartitionMetadata::DynamicPartitionMetadata(const DynamicPartitionMetadata& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      groups_(from.groups_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  vabc_compression_param_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_vabc_compression_param()) {
    vabc_compression_param_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vabc_compression_param_);
  }
  if (from.has_vabc_feature_set()) {
    vabc_feature_set_ = new ::chromeos_update_engine::VABCFeatureSet(*from.vabc_feature_set_);
  } else {
    vabc_feature_set_ = nullptr;
  }
  ::memcpy(&snapshot_enabled_, &from.snapshot_enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&cow_version_) -
    reinterpret_cast<char*>(&snapshot_enabled_)) + sizeof(cow_version_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.DynamicPartitionMetadata)
}

void DynamicPartitionMetadata::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_DynamicPartitionMetadata_update_5fmetadata_2eproto.base);
  vabc_compression_param_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&vabc_feature_set_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cow_version_) -
      reinterpret_cast<char*>(&vabc_feature_set_)) + sizeof(cow_version_));
}

DynamicPartitionMetadata::~DynamicPartitionMetadata() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.DynamicPartitionMetadata)
  SharedDtor();
}

void DynamicPartitionMetadata::SharedDtor() {
  vabc_compression_param_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete vabc_feature_set_;
}

void DynamicPartitionMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DynamicPartitionMetadata& DynamicPartitionMetadata::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_DynamicPartitionMetadata_update_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void DynamicPartitionMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.DynamicPartitionMetadata)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  groups_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      vabc_compression_param_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(vabc_feature_set_ != nullptr);
      vabc_feature_set_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&snapshot_enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cow_version_) -
        reinterpret_cast<char*>(&snapshot_enabled_)) + sizeof(cow_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* DynamicPartitionMetadata::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<DynamicPartitionMetadata*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::chromeos_update_engine::DynamicPartitionGroup::_InternalParse;
          object = msg->add_groups();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      // optional bool snapshot_enabled = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_snapshot_enabled(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool vabc_enabled = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_vabc_enabled(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional string vabc_compression_param = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_vabc_compression_param();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional uint32 cow_version = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_cow_version(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 50) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::chromeos_update_engine::VABCFeatureSet::_InternalParse;
        object = msg->mutable_vabc_feature_set();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool DynamicPartitionMetadata::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.DynamicPartitionMetadata)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_groups()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool snapshot_enabled = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_snapshot_enabled(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &snapshot_enabled_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool vabc_enabled = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_vabc_enabled(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &vabc_enabled_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string vabc_compression_param = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vabc_compression_param()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 cow_version = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_cow_version(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cow_version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (50 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_vabc_feature_set()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.DynamicPartitionMetadata)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.DynamicPartitionMetadata)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void DynamicPartitionMetadata::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.DynamicPartitionMetadata)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->groups_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1,
      this->groups(static_cast<int>(i)),
      output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool snapshot_enabled = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->snapshot_enabled(), output);
  }

  // optional bool vabc_enabled = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->vabc_enabled(), output);
  }

  // optional string vabc_compression_param = 4;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->vabc_compression_param(), output);
  }

  // optional uint32 cow_version = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->cow_version(), output);
  }

  // optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, HasBitSetters::vabc_feature_set(this), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.DynamicPartitionMetadata)
}

size_t DynamicPartitionMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.DynamicPartitionMetadata)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->groups_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->groups(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string vabc_compression_param = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->vabc_compression_param());
    }

    // optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *vabc_feature_set_);
    }

    // optional bool snapshot_enabled = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool vabc_enabled = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional uint32 cow_version = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cow_version());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DynamicPartitionMetadata::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DynamicPartitionMetadata*>(&from));
}

void DynamicPartitionMetadata::MergeFrom(const DynamicPartitionMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.DynamicPartitionMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  groups_.MergeFrom(from.groups_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      vabc_compression_param_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vabc_compression_param_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_vabc_feature_set()->::chromeos_update_engine::VABCFeatureSet::MergeFrom(from.vabc_feature_set());
    }
    if (cached_has_bits & 0x00000004u) {
      snapshot_enabled_ = from.snapshot_enabled_;
    }
    if (cached_has_bits & 0x00000008u) {
      vabc_enabled_ = from.vabc_enabled_;
    }
    if (cached_has_bits & 0x00000010u) {
      cow_version_ = from.cow_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DynamicPartitionMetadata::CopyFrom(const DynamicPartitionMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.DynamicPartitionMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DynamicPartitionMetadata::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->groups())) return false;
  return true;
}

void DynamicPartitionMetadata::Swap(DynamicPartitionMetadata* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DynamicPartitionMetadata::InternalSwap(DynamicPartitionMetadata* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&groups_)->InternalSwap(CastToBase(&other->groups_));
  vabc_compression_param_.Swap(&other->vabc_compression_param_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(vabc_feature_set_, other->vabc_feature_set_);
  swap(snapshot_enabled_, other->snapshot_enabled_);
  swap(vabc_enabled_, other->vabc_enabled_);
  swap(cow_version_, other->cow_version_);
}

::std::string DynamicPartitionMetadata::GetTypeName() const {
  return "chromeos_update_engine.DynamicPartitionMetadata";
}


// ===================================================================

void ApexInfo::InitAsDefaultInstance() {
}
class ApexInfo::HasBitSetters {
 public:
  static void set_has_package_name(ApexInfo* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
  static void set_has_version(ApexInfo* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_is_compressed(ApexInfo* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_decompressed_size(ApexInfo* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ApexInfo::kPackageNameFieldNumber;
const int ApexInfo::kVersionFieldNumber;
const int ApexInfo::kIsCompressedFieldNumber;
const int ApexInfo::kDecompressedSizeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ApexInfo::ApexInfo()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.ApexInfo)
}
ApexInfo::ApexInfo(const ApexInfo& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  package_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_package_name()) {
    package_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.package_name_);
  }
  ::memcpy(&version_, &from.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_compressed_) -
    reinterpret_cast<char*>(&version_)) + sizeof(is_compressed_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.ApexInfo)
}

void ApexInfo::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ApexInfo_update_5fmetadata_2eproto.base);
  package_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_compressed_) -
      reinterpret_cast<char*>(&version_)) + sizeof(is_compressed_));
}

ApexInfo::~ApexInfo() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.ApexInfo)
  SharedDtor();
}

void ApexInfo::SharedDtor() {
  package_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ApexInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ApexInfo& ApexInfo::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ApexInfo_update_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void ApexInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.ApexInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    package_name_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_compressed_) -
        reinterpret_cast<char*>(&version_)) + sizeof(is_compressed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ApexInfo::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ApexInfo*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional string package_name = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_package_name();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      // optional int64 version = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        msg->set_version(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional bool is_compressed = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_is_compressed(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional int64 decompressed_size = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_decompressed_size(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ApexInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.ApexInfo)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string package_name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 version = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {
          HasBitSetters::set_has_version(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_compressed = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_is_compressed(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_compressed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 decompressed_size = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_decompressed_size(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &decompressed_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.ApexInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.ApexInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ApexInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.ApexInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string package_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->package_name(), output);
  }

  // optional int64 version = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->version(), output);
  }

  // optional bool is_compressed = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->is_compressed(), output);
  }

  // optional int64 decompressed_size = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->decompressed_size(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.ApexInfo)
}

size_t ApexInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.ApexInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string package_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package_name());
    }

    // optional int64 version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->version());
    }

    // optional int64 decompressed_size = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->decompressed_size());
    }

    // optional bool is_compressed = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ApexInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ApexInfo*>(&from));
}

void ApexInfo::MergeFrom(const ApexInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.ApexInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      package_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.package_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000004u) {
      decompressed_size_ = from.decompressed_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      is_compressed_ = from.is_compressed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ApexInfo::CopyFrom(const ApexInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.ApexInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApexInfo::IsInitialized() const {
  return true;
}

void ApexInfo::Swap(ApexInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ApexInfo::InternalSwap(ApexInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  package_name_.Swap(&other->package_name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(version_, other->version_);
  swap(decompressed_size_, other->decompressed_size_);
  swap(is_compressed_, other->is_compressed_);
}

::std::string ApexInfo::GetTypeName() const {
  return "chromeos_update_engine.ApexInfo";
}


// ===================================================================

void ApexMetadata::InitAsDefaultInstance() {
}
class ApexMetadata::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ApexMetadata::kApexInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ApexMetadata::ApexMetadata()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.ApexMetadata)
}
ApexMetadata::ApexMetadata(const ApexMetadata& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      apex_info_(from.apex_info_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.ApexMetadata)
}

void ApexMetadata::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_ApexMetadata_update_5fmetadata_2eproto.base);
}

ApexMetadata::~ApexMetadata() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.ApexMetadata)
  SharedDtor();
}

void ApexMetadata::SharedDtor() {
}

void ApexMetadata::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ApexMetadata& ApexMetadata::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_ApexMetadata_update_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void ApexMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.ApexMetadata)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  apex_info_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ApexMetadata::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<ApexMetadata*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .chromeos_update_engine.ApexInfo apex_info = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::chromeos_update_engine::ApexInfo::_InternalParse;
          object = msg->add_apex_info();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ApexMetadata::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.ApexMetadata)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .chromeos_update_engine.ApexInfo apex_info = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_apex_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.ApexMetadata)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.ApexMetadata)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ApexMetadata::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.ApexMetadata)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.ApexInfo apex_info = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->apex_info_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1,
      this->apex_info(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.ApexMetadata)
}

size_t ApexMetadata::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.ApexMetadata)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.ApexInfo apex_info = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->apex_info_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->apex_info(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ApexMetadata::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ApexMetadata*>(&from));
}

void ApexMetadata::MergeFrom(const ApexMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.ApexMetadata)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  apex_info_.MergeFrom(from.apex_info_);
}

void ApexMetadata::CopyFrom(const ApexMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.ApexMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApexMetadata::IsInitialized() const {
  return true;
}

void ApexMetadata::Swap(ApexMetadata* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ApexMetadata::InternalSwap(ApexMetadata* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&apex_info_)->InternalSwap(CastToBase(&other->apex_info_));
}

::std::string ApexMetadata::GetTypeName() const {
  return "chromeos_update_engine.ApexMetadata";
}


// ===================================================================

void DeltaArchiveManifest::InitAsDefaultInstance() {
  ::chromeos_update_engine::_DeltaArchiveManifest_default_instance_._instance.get_mutable()->dynamic_partition_metadata_ = const_cast< ::chromeos_update_engine::DynamicPartitionMetadata*>(
      ::chromeos_update_engine::DynamicPartitionMetadata::internal_default_instance());
}
class DeltaArchiveManifest::HasBitSetters {
 public:
  static void set_has_block_size(DeltaArchiveManifest* msg) {
    msg->_has_bits_[0] |= 0x00000080u;
  }
  static void set_has_signatures_offset(DeltaArchiveManifest* msg) {
    msg->_has_bits_[0] |= 0x00000004u;
  }
  static void set_has_signatures_size(DeltaArchiveManifest* msg) {
    msg->_has_bits_[0] |= 0x00000008u;
  }
  static void set_has_minor_version(DeltaArchiveManifest* msg) {
    msg->_has_bits_[0] |= 0x00000020u;
  }
  static void set_has_max_timestamp(DeltaArchiveManifest* msg) {
    msg->_has_bits_[0] |= 0x00000010u;
  }
  static const ::chromeos_update_engine::DynamicPartitionMetadata& dynamic_partition_metadata(const DeltaArchiveManifest* msg);
  static void set_has_dynamic_partition_metadata(DeltaArchiveManifest* msg) {
    msg->_has_bits_[0] |= 0x00000002u;
  }
  static void set_has_partial_update(DeltaArchiveManifest* msg) {
    msg->_has_bits_[0] |= 0x00000040u;
  }
  static void set_has_security_patch_level(DeltaArchiveManifest* msg) {
    msg->_has_bits_[0] |= 0x00000001u;
  }
};

const ::chromeos_update_engine::DynamicPartitionMetadata&
DeltaArchiveManifest::HasBitSetters::dynamic_partition_metadata(const DeltaArchiveManifest* msg) {
  return *msg->dynamic_partition_metadata_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DeltaArchiveManifest::kBlockSizeFieldNumber;
const int DeltaArchiveManifest::kSignaturesOffsetFieldNumber;
const int DeltaArchiveManifest::kSignaturesSizeFieldNumber;
const int DeltaArchiveManifest::kMinorVersionFieldNumber;
const int DeltaArchiveManifest::kPartitionsFieldNumber;
const int DeltaArchiveManifest::kMaxTimestampFieldNumber;
const int DeltaArchiveManifest::kDynamicPartitionMetadataFieldNumber;
const int DeltaArchiveManifest::kPartialUpdateFieldNumber;
const int DeltaArchiveManifest::kApexInfoFieldNumber;
const int DeltaArchiveManifest::kSecurityPatchLevelFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DeltaArchiveManifest::DeltaArchiveManifest()
  : ::google::protobuf::MessageLite(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:chromeos_update_engine.DeltaArchiveManifest)
}
DeltaArchiveManifest::DeltaArchiveManifest(const DeltaArchiveManifest& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      partitions_(from.partitions_),
      apex_info_(from.apex_info_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  security_patch_level_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_security_patch_level()) {
    security_patch_level_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.security_patch_level_);
  }
  if (from.has_dynamic_partition_metadata()) {
    dynamic_partition_metadata_ = new ::chromeos_update_engine::DynamicPartitionMetadata(*from.dynamic_partition_metadata_);
  } else {
    dynamic_partition_metadata_ = nullptr;
  }
  ::memcpy(&signatures_offset_, &from.signatures_offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&block_size_) -
    reinterpret_cast<char*>(&signatures_offset_)) + sizeof(block_size_));
  // @@protoc_insertion_point(copy_constructor:chromeos_update_engine.DeltaArchiveManifest)
}

void DeltaArchiveManifest::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_DeltaArchiveManifest_update_5fmetadata_2eproto.base);
  security_patch_level_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&dynamic_partition_metadata_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&partial_update_) -
      reinterpret_cast<char*>(&dynamic_partition_metadata_)) + sizeof(partial_update_));
  block_size_ = 4096u;
}

DeltaArchiveManifest::~DeltaArchiveManifest() {
  // @@protoc_insertion_point(destructor:chromeos_update_engine.DeltaArchiveManifest)
  SharedDtor();
}

void DeltaArchiveManifest::SharedDtor() {
  security_patch_level_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete dynamic_partition_metadata_;
}

void DeltaArchiveManifest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DeltaArchiveManifest& DeltaArchiveManifest::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_DeltaArchiveManifest_update_5fmetadata_2eproto.base);
  return *internal_default_instance();
}


void DeltaArchiveManifest::Clear() {
// @@protoc_insertion_point(message_clear_start:chromeos_update_engine.DeltaArchiveManifest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  partitions_.Clear();
  apex_info_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      security_patch_level_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(dynamic_partition_metadata_ != nullptr);
      dynamic_partition_metadata_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&signatures_offset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&partial_update_) -
        reinterpret_cast<char*>(&signatures_offset_)) + sizeof(partial_update_));
    block_size_ = 4096u;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* DeltaArchiveManifest::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<DeltaArchiveManifest*>(object);
  ::google::protobuf::int32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ptr = ::google::protobuf::io::Parse32(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // optional uint32 block_size = 3 [default = 4096];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        msg->set_block_size(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 signatures_offset = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        msg->set_signatures_offset(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint64 signatures_size = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        msg->set_signatures_size(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional uint32 minor_version = 12 [default = 0];
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 96) goto handle_unusual;
        msg->set_minor_version(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
      case 13: {
        if (static_cast<::google::protobuf::uint8>(tag) != 106) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::chromeos_update_engine::PartitionUpdate::_InternalParse;
          object = msg->add_partitions();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 106 && (ptr += 1));
        break;
      }
      // optional int64 max_timestamp = 14;
      case 14: {
        if (static_cast<::google::protobuf::uint8>(tag) != 112) goto handle_unusual;
        msg->set_max_timestamp(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
      case 15: {
        if (static_cast<::google::protobuf::uint8>(tag) != 122) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::chromeos_update_engine::DynamicPartitionMetadata::_InternalParse;
        object = msg->mutable_dynamic_partition_metadata();
        if (size > end - ptr) goto len_delim_till_end;
        ptr += size;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
            {parser_till_end, object}, ptr - size, ptr));
        break;
      }
      // optional bool partial_update = 16;
      case 16: {
        if (static_cast<::google::protobuf::uint8>(tag) != 128) goto handle_unusual;
        msg->set_partial_update(::google::protobuf::internal::ReadVarint(&ptr));
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        break;
      }
      // repeated .chromeos_update_engine.ApexInfo apex_info = 17;
      case 17: {
        if (static_cast<::google::protobuf::uint8>(tag) != 138) goto handle_unusual;
        do {
          ptr = ::google::protobuf::io::ReadSize(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::chromeos_update_engine::ApexInfo::_InternalParse;
          object = msg->add_apex_info();
          if (size > end - ptr) goto len_delim_till_end;
          ptr += size;
          GOOGLE_PROTOBUF_PARSER_ASSERT(ctx->ParseExactRange(
              {parser_till_end, object}, ptr - size, ptr));
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 65535) == 394 && (ptr += 2));
        break;
      }
      // optional string security_patch_level = 18;
      case 18: {
        if (static_cast<::google::protobuf::uint8>(tag) != 146) goto handle_unusual;
        ptr = ::google::protobuf::io::ReadSize(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        object = msg->mutable_security_patch_level();
        if (size > end - ptr + ::google::protobuf::internal::ParseContext::kSlopBytes) {
          parser_till_end = ::google::protobuf::internal::GreedyStringParser;
          goto string_till_end;
        }
        GOOGLE_PROTOBUF_PARSER_ASSERT(::google::protobuf::internal::StringCheck(ptr, size, ctx));
        ::google::protobuf::internal::InlineGreedyStringParser(object, ptr, size, ctx);
        ptr += size;
        break;
      }
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->EndGroup(tag);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr != nullptr);
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
string_till_end:
  static_cast<::std::string*>(object)->clear();
  static_cast<::std::string*>(object)->reserve(size);
  goto len_delim_till_end;
len_delim_till_end:
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                               {parser_till_end, object}, size);
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool DeltaArchiveManifest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:chromeos_update_engine.DeltaArchiveManifest)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 block_size = 3 [default = 4096];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {
          HasBitSetters::set_has_block_size(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &block_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 signatures_offset = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {
          HasBitSetters::set_has_signatures_offset(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &signatures_offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 signatures_size = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {
          HasBitSetters::set_has_signatures_size(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &signatures_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 minor_version = 12 [default = 0];
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (96 & 0xFF)) {
          HasBitSetters::set_has_minor_version(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &minor_version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (106 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_partitions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 max_timestamp = 14;
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (112 & 0xFF)) {
          HasBitSetters::set_has_max_timestamp(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &max_timestamp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (122 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_dynamic_partition_metadata()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool partial_update = 16;
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (128 & 0xFF)) {
          HasBitSetters::set_has_partial_update(this);
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &partial_update_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .chromeos_update_engine.ApexInfo apex_info = 17;
      case 17: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (138 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_apex_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string security_patch_level = 18;
      case 18: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (146 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_security_patch_level()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:chromeos_update_engine.DeltaArchiveManifest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:chromeos_update_engine.DeltaArchiveManifest)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void DeltaArchiveManifest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:chromeos_update_engine.DeltaArchiveManifest)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 block_size = 3 [default = 4096];
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->block_size(), output);
  }

  // optional uint64 signatures_offset = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->signatures_offset(), output);
  }

  // optional uint64 signatures_size = 5;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->signatures_size(), output);
  }

  // optional uint32 minor_version = 12 [default = 0];
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->minor_version(), output);
  }

  // repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->partitions_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      13,
      this->partitions(static_cast<int>(i)),
      output);
  }

  // optional int64 max_timestamp = 14;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(14, this->max_timestamp(), output);
  }

  // optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      15, HasBitSetters::dynamic_partition_metadata(this), output);
  }

  // optional bool partial_update = 16;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(16, this->partial_update(), output);
  }

  // repeated .chromeos_update_engine.ApexInfo apex_info = 17;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->apex_info_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      17,
      this->apex_info(static_cast<int>(i)),
      output);
  }

  // optional string security_patch_level = 18;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      18, this->security_patch_level(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:chromeos_update_engine.DeltaArchiveManifest)
}

size_t DeltaArchiveManifest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chromeos_update_engine.DeltaArchiveManifest)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
  {
    unsigned int count = static_cast<unsigned int>(this->partitions_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->partitions(static_cast<int>(i)));
    }
  }

  // repeated .chromeos_update_engine.ApexInfo apex_info = 17;
  {
    unsigned int count = static_cast<unsigned int>(this->apex_info_size());
    total_size += 2UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->apex_info(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string security_patch_level = 18;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->security_patch_level());
    }

    // optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *dynamic_partition_metadata_);
    }

    // optional uint64 signatures_offset = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->signatures_offset());
    }

    // optional uint64 signatures_size = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->signatures_size());
    }

    // optional int64 max_timestamp = 14;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->max_timestamp());
    }

    // optional uint32 minor_version = 12 [default = 0];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->minor_version());
    }

    // optional bool partial_update = 16;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 + 1;
    }

    // optional uint32 block_size = 3 [default = 4096];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->block_size());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DeltaArchiveManifest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DeltaArchiveManifest*>(&from));
}

void DeltaArchiveManifest::MergeFrom(const DeltaArchiveManifest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chromeos_update_engine.DeltaArchiveManifest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  partitions_.MergeFrom(from.partitions_);
  apex_info_.MergeFrom(from.apex_info_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      security_patch_level_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.security_patch_level_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_dynamic_partition_metadata()->::chromeos_update_engine::DynamicPartitionMetadata::MergeFrom(from.dynamic_partition_metadata());
    }
    if (cached_has_bits & 0x00000004u) {
      signatures_offset_ = from.signatures_offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      signatures_size_ = from.signatures_size_;
    }
    if (cached_has_bits & 0x00000010u) {
      max_timestamp_ = from.max_timestamp_;
    }
    if (cached_has_bits & 0x00000020u) {
      minor_version_ = from.minor_version_;
    }
    if (cached_has_bits & 0x00000040u) {
      partial_update_ = from.partial_update_;
    }
    if (cached_has_bits & 0x00000080u) {
      block_size_ = from.block_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DeltaArchiveManifest::CopyFrom(const DeltaArchiveManifest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chromeos_update_engine.DeltaArchiveManifest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeltaArchiveManifest::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->partitions())) return false;
  if (has_dynamic_partition_metadata()) {
    if (!this->dynamic_partition_metadata_->IsInitialized()) return false;
  }
  return true;
}

void DeltaArchiveManifest::Swap(DeltaArchiveManifest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeltaArchiveManifest::InternalSwap(DeltaArchiveManifest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&partitions_)->InternalSwap(CastToBase(&other->partitions_));
  CastToBase(&apex_info_)->InternalSwap(CastToBase(&other->apex_info_));
  security_patch_level_.Swap(&other->security_patch_level_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(dynamic_partition_metadata_, other->dynamic_partition_metadata_);
  swap(signatures_offset_, other->signatures_offset_);
  swap(signatures_size_, other->signatures_size_);
  swap(max_timestamp_, other->max_timestamp_);
  swap(minor_version_, other->minor_version_);
  swap(partial_update_, other->partial_update_);
  swap(block_size_, other->block_size_);
}

::std::string DeltaArchiveManifest::GetTypeName() const {
  return "chromeos_update_engine.DeltaArchiveManifest";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace chromeos_update_engine
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::Extent* Arena::CreateMaybeMessage< ::chromeos_update_engine::Extent >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::Extent >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::Signatures_Signature* Arena::CreateMaybeMessage< ::chromeos_update_engine::Signatures_Signature >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::Signatures_Signature >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::Signatures* Arena::CreateMaybeMessage< ::chromeos_update_engine::Signatures >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::Signatures >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::PartitionInfo* Arena::CreateMaybeMessage< ::chromeos_update_engine::PartitionInfo >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::PartitionInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::InstallOperation* Arena::CreateMaybeMessage< ::chromeos_update_engine::InstallOperation >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::InstallOperation >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::CowMergeOperation* Arena::CreateMaybeMessage< ::chromeos_update_engine::CowMergeOperation >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::CowMergeOperation >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::PartitionUpdate* Arena::CreateMaybeMessage< ::chromeos_update_engine::PartitionUpdate >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::PartitionUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::DynamicPartitionGroup* Arena::CreateMaybeMessage< ::chromeos_update_engine::DynamicPartitionGroup >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::DynamicPartitionGroup >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::VABCFeatureSet* Arena::CreateMaybeMessage< ::chromeos_update_engine::VABCFeatureSet >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::VABCFeatureSet >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::DynamicPartitionMetadata* Arena::CreateMaybeMessage< ::chromeos_update_engine::DynamicPartitionMetadata >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::DynamicPartitionMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::ApexInfo* Arena::CreateMaybeMessage< ::chromeos_update_engine::ApexInfo >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::ApexInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::ApexMetadata* Arena::CreateMaybeMessage< ::chromeos_update_engine::ApexMetadata >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::ApexMetadata >(arena);
}
template<> PROTOBUF_NOINLINE ::chromeos_update_engine::DeltaArchiveManifest* Arena::CreateMaybeMessage< ::chromeos_update_engine::DeltaArchiveManifest >(Arena* arena) {
  return Arena::CreateInternal< ::chromeos_update_engine::DeltaArchiveManifest >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
