// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: update_metadata.proto

#ifndef PROTOBUF_INCLUDED_update_5fmetadata_2eproto
#define PROTOBUF_INCLUDED_update_5fmetadata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_update_5fmetadata_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_update_5fmetadata_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
namespace chromeos_update_engine {
class ApexInfo;
class ApexInfoDefaultTypeInternal;
extern ApexInfoDefaultTypeInternal _ApexInfo_default_instance_;
class ApexMetadata;
class ApexMetadataDefaultTypeInternal;
extern ApexMetadataDefaultTypeInternal _ApexMetadata_default_instance_;
class CowMergeOperation;
class CowMergeOperationDefaultTypeInternal;
extern CowMergeOperationDefaultTypeInternal _CowMergeOperation_default_instance_;
class DeltaArchiveManifest;
class DeltaArchiveManifestDefaultTypeInternal;
extern DeltaArchiveManifestDefaultTypeInternal _DeltaArchiveManifest_default_instance_;
class DynamicPartitionGroup;
class DynamicPartitionGroupDefaultTypeInternal;
extern DynamicPartitionGroupDefaultTypeInternal _DynamicPartitionGroup_default_instance_;
class DynamicPartitionMetadata;
class DynamicPartitionMetadataDefaultTypeInternal;
extern DynamicPartitionMetadataDefaultTypeInternal _DynamicPartitionMetadata_default_instance_;
class Extent;
class ExtentDefaultTypeInternal;
extern ExtentDefaultTypeInternal _Extent_default_instance_;
class InstallOperation;
class InstallOperationDefaultTypeInternal;
extern InstallOperationDefaultTypeInternal _InstallOperation_default_instance_;
class PartitionInfo;
class PartitionInfoDefaultTypeInternal;
extern PartitionInfoDefaultTypeInternal _PartitionInfo_default_instance_;
class PartitionUpdate;
class PartitionUpdateDefaultTypeInternal;
extern PartitionUpdateDefaultTypeInternal _PartitionUpdate_default_instance_;
class Signatures;
class SignaturesDefaultTypeInternal;
extern SignaturesDefaultTypeInternal _Signatures_default_instance_;
class Signatures_Signature;
class Signatures_SignatureDefaultTypeInternal;
extern Signatures_SignatureDefaultTypeInternal _Signatures_Signature_default_instance_;
class VABCFeatureSet;
class VABCFeatureSetDefaultTypeInternal;
extern VABCFeatureSetDefaultTypeInternal _VABCFeatureSet_default_instance_;
}  // namespace chromeos_update_engine
namespace google {
namespace protobuf {
template<> ::chromeos_update_engine::ApexInfo* Arena::CreateMaybeMessage<::chromeos_update_engine::ApexInfo>(Arena*);
template<> ::chromeos_update_engine::ApexMetadata* Arena::CreateMaybeMessage<::chromeos_update_engine::ApexMetadata>(Arena*);
template<> ::chromeos_update_engine::CowMergeOperation* Arena::CreateMaybeMessage<::chromeos_update_engine::CowMergeOperation>(Arena*);
template<> ::chromeos_update_engine::DeltaArchiveManifest* Arena::CreateMaybeMessage<::chromeos_update_engine::DeltaArchiveManifest>(Arena*);
template<> ::chromeos_update_engine::DynamicPartitionGroup* Arena::CreateMaybeMessage<::chromeos_update_engine::DynamicPartitionGroup>(Arena*);
template<> ::chromeos_update_engine::DynamicPartitionMetadata* Arena::CreateMaybeMessage<::chromeos_update_engine::DynamicPartitionMetadata>(Arena*);
template<> ::chromeos_update_engine::Extent* Arena::CreateMaybeMessage<::chromeos_update_engine::Extent>(Arena*);
template<> ::chromeos_update_engine::InstallOperation* Arena::CreateMaybeMessage<::chromeos_update_engine::InstallOperation>(Arena*);
template<> ::chromeos_update_engine::PartitionInfo* Arena::CreateMaybeMessage<::chromeos_update_engine::PartitionInfo>(Arena*);
template<> ::chromeos_update_engine::PartitionUpdate* Arena::CreateMaybeMessage<::chromeos_update_engine::PartitionUpdate>(Arena*);
template<> ::chromeos_update_engine::Signatures* Arena::CreateMaybeMessage<::chromeos_update_engine::Signatures>(Arena*);
template<> ::chromeos_update_engine::Signatures_Signature* Arena::CreateMaybeMessage<::chromeos_update_engine::Signatures_Signature>(Arena*);
template<> ::chromeos_update_engine::VABCFeatureSet* Arena::CreateMaybeMessage<::chromeos_update_engine::VABCFeatureSet>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace chromeos_update_engine {

enum InstallOperation_Type {
  InstallOperation_Type_REPLACE = 0,
  InstallOperation_Type_REPLACE_BZ = 1,
  InstallOperation_Type_MOVE PROTOBUF_DEPRECATED = 2,
  InstallOperation_Type_BSDIFF PROTOBUF_DEPRECATED = 3,
  InstallOperation_Type_SOURCE_COPY = 4,
  InstallOperation_Type_SOURCE_BSDIFF = 5,
  InstallOperation_Type_REPLACE_XZ = 8,
  InstallOperation_Type_ZERO = 6,
  InstallOperation_Type_DISCARD = 7,
  InstallOperation_Type_BROTLI_BSDIFF = 10,
  InstallOperation_Type_PUFFDIFF = 9,
  InstallOperation_Type_ZUCCHINI = 11,
  InstallOperation_Type_LZ4DIFF_BSDIFF = 12,
  InstallOperation_Type_LZ4DIFF_PUFFDIFF = 13
};
bool InstallOperation_Type_IsValid(int value);
const InstallOperation_Type InstallOperation_Type_Type_MIN = InstallOperation_Type_REPLACE;
const InstallOperation_Type InstallOperation_Type_Type_MAX = InstallOperation_Type_LZ4DIFF_PUFFDIFF;
const int InstallOperation_Type_Type_ARRAYSIZE = InstallOperation_Type_Type_MAX + 1;

enum CowMergeOperation_Type {
  CowMergeOperation_Type_COW_COPY = 0,
  CowMergeOperation_Type_COW_XOR = 1,
  CowMergeOperation_Type_COW_REPLACE = 2
};
bool CowMergeOperation_Type_IsValid(int value);
const CowMergeOperation_Type CowMergeOperation_Type_Type_MIN = CowMergeOperation_Type_COW_COPY;
const CowMergeOperation_Type CowMergeOperation_Type_Type_MAX = CowMergeOperation_Type_COW_REPLACE;
const int CowMergeOperation_Type_Type_ARRAYSIZE = CowMergeOperation_Type_Type_MAX + 1;

// ===================================================================

class Extent :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.Extent) */ {
 public:
  Extent();
  virtual ~Extent();

  Extent(const Extent& from);

  inline Extent& operator=(const Extent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Extent(Extent&& from) noexcept
    : Extent() {
    *this = ::std::move(from);
  }

  inline Extent& operator=(Extent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Extent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Extent* internal_default_instance() {
    return reinterpret_cast<const Extent*>(
               &_Extent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Extent* other);
  friend void swap(Extent& a, Extent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Extent* New() const final {
    return CreateMaybeMessage<Extent>(nullptr);
  }

  Extent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Extent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Extent& from);
  void MergeFrom(const Extent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Extent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 start_block = 1;
  bool has_start_block() const;
  void clear_start_block();
  static const int kStartBlockFieldNumber = 1;
  ::google::protobuf::uint64 start_block() const;
  void set_start_block(::google::protobuf::uint64 value);

  // optional uint64 num_blocks = 2;
  bool has_num_blocks() const;
  void clear_num_blocks();
  static const int kNumBlocksFieldNumber = 2;
  ::google::protobuf::uint64 num_blocks() const;
  void set_num_blocks(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 start_block_;
  ::google::protobuf::uint64 num_blocks_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class Signatures_Signature :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.Signatures.Signature) */ {
 public:
  Signatures_Signature();
  virtual ~Signatures_Signature();

  Signatures_Signature(const Signatures_Signature& from);

  inline Signatures_Signature& operator=(const Signatures_Signature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signatures_Signature(Signatures_Signature&& from) noexcept
    : Signatures_Signature() {
    *this = ::std::move(from);
  }

  inline Signatures_Signature& operator=(Signatures_Signature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Signatures_Signature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signatures_Signature* internal_default_instance() {
    return reinterpret_cast<const Signatures_Signature*>(
               &_Signatures_Signature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Signatures_Signature* other);
  friend void swap(Signatures_Signature& a, Signatures_Signature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signatures_Signature* New() const final {
    return CreateMaybeMessage<Signatures_Signature>(nullptr);
  }

  Signatures_Signature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Signatures_Signature>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Signatures_Signature& from);
  void MergeFrom(const Signatures_Signature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Signatures_Signature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional uint32 version = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_version() const;
  PROTOBUF_DEPRECATED void clear_version();
  PROTOBUF_DEPRECATED static const int kVersionFieldNumber = 1;
  PROTOBUF_DEPRECATED ::google::protobuf::uint32 version() const;
  PROTOBUF_DEPRECATED void set_version(::google::protobuf::uint32 value);

  // optional fixed32 unpadded_signature_size = 3;
  bool has_unpadded_signature_size() const;
  void clear_unpadded_signature_size();
  static const int kUnpaddedSignatureSizeFieldNumber = 3;
  ::google::protobuf::uint32 unpadded_signature_size() const;
  void set_unpadded_signature_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures.Signature)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 unpadded_signature_size_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class Signatures :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.Signatures) */ {
 public:
  Signatures();
  virtual ~Signatures();

  Signatures(const Signatures& from);

  inline Signatures& operator=(const Signatures& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signatures(Signatures&& from) noexcept
    : Signatures() {
    *this = ::std::move(from);
  }

  inline Signatures& operator=(Signatures&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Signatures& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signatures* internal_default_instance() {
    return reinterpret_cast<const Signatures*>(
               &_Signatures_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Signatures* other);
  friend void swap(Signatures& a, Signatures& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signatures* New() const final {
    return CreateMaybeMessage<Signatures>(nullptr);
  }

  Signatures* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Signatures>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const Signatures& from);
  void MergeFrom(const Signatures& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Signatures* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Signatures_Signature Signature;

  // accessors -------------------------------------------------------

  // repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
  int signatures_size() const;
  void clear_signatures();
  static const int kSignaturesFieldNumber = 1;
  ::chromeos_update_engine::Signatures_Signature* mutable_signatures(int index);
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >*
      mutable_signatures();
  const ::chromeos_update_engine::Signatures_Signature& signatures(int index) const;
  ::chromeos_update_engine::Signatures_Signature* add_signatures();
  const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >&
      signatures() const;

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature > signatures_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class PartitionInfo :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.PartitionInfo) */ {
 public:
  PartitionInfo();
  virtual ~PartitionInfo();

  PartitionInfo(const PartitionInfo& from);

  inline PartitionInfo& operator=(const PartitionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartitionInfo(PartitionInfo&& from) noexcept
    : PartitionInfo() {
    *this = ::std::move(from);
  }

  inline PartitionInfo& operator=(PartitionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PartitionInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartitionInfo* internal_default_instance() {
    return reinterpret_cast<const PartitionInfo*>(
               &_PartitionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PartitionInfo* other);
  friend void swap(PartitionInfo& a, PartitionInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartitionInfo* New() const final {
    return CreateMaybeMessage<PartitionInfo>(nullptr);
  }

  PartitionInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PartitionInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PartitionInfo& from);
  void MergeFrom(const PartitionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PartitionInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes hash = 2;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // optional uint64 size = 1;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 1;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::uint64 size_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class InstallOperation :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.InstallOperation) */ {
 public:
  InstallOperation();
  virtual ~InstallOperation();

  InstallOperation(const InstallOperation& from);

  inline InstallOperation& operator=(const InstallOperation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InstallOperation(InstallOperation&& from) noexcept
    : InstallOperation() {
    *this = ::std::move(from);
  }

  inline InstallOperation& operator=(InstallOperation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const InstallOperation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InstallOperation* internal_default_instance() {
    return reinterpret_cast<const InstallOperation*>(
               &_InstallOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(InstallOperation* other);
  friend void swap(InstallOperation& a, InstallOperation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InstallOperation* New() const final {
    return CreateMaybeMessage<InstallOperation>(nullptr);
  }

  InstallOperation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InstallOperation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const InstallOperation& from);
  void MergeFrom(const InstallOperation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InstallOperation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef InstallOperation_Type Type;
  static const Type REPLACE =
    InstallOperation_Type_REPLACE;
  static const Type REPLACE_BZ =
    InstallOperation_Type_REPLACE_BZ;
  PROTOBUF_DEPRECATED static const Type MOVE =
    InstallOperation_Type_MOVE;
  PROTOBUF_DEPRECATED static const Type BSDIFF =
    InstallOperation_Type_BSDIFF;
  static const Type SOURCE_COPY =
    InstallOperation_Type_SOURCE_COPY;
  static const Type SOURCE_BSDIFF =
    InstallOperation_Type_SOURCE_BSDIFF;
  static const Type REPLACE_XZ =
    InstallOperation_Type_REPLACE_XZ;
  static const Type ZERO =
    InstallOperation_Type_ZERO;
  static const Type DISCARD =
    InstallOperation_Type_DISCARD;
  static const Type BROTLI_BSDIFF =
    InstallOperation_Type_BROTLI_BSDIFF;
  static const Type PUFFDIFF =
    InstallOperation_Type_PUFFDIFF;
  static const Type ZUCCHINI =
    InstallOperation_Type_ZUCCHINI;
  static const Type LZ4DIFF_BSDIFF =
    InstallOperation_Type_LZ4DIFF_BSDIFF;
  static const Type LZ4DIFF_PUFFDIFF =
    InstallOperation_Type_LZ4DIFF_PUFFDIFF;
  static inline bool Type_IsValid(int value) {
    return InstallOperation_Type_IsValid(value);
  }
  static const Type Type_MIN =
    InstallOperation_Type_Type_MIN;
  static const Type Type_MAX =
    InstallOperation_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    InstallOperation_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .chromeos_update_engine.Extent src_extents = 4;
  int src_extents_size() const;
  void clear_src_extents();
  static const int kSrcExtentsFieldNumber = 4;
  ::chromeos_update_engine::Extent* mutable_src_extents(int index);
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent >*
      mutable_src_extents();
  const ::chromeos_update_engine::Extent& src_extents(int index) const;
  ::chromeos_update_engine::Extent* add_src_extents();
  const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent >&
      src_extents() const;

  // repeated .chromeos_update_engine.Extent dst_extents = 6;
  int dst_extents_size() const;
  void clear_dst_extents();
  static const int kDstExtentsFieldNumber = 6;
  ::chromeos_update_engine::Extent* mutable_dst_extents(int index);
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent >*
      mutable_dst_extents();
  const ::chromeos_update_engine::Extent& dst_extents(int index) const;
  ::chromeos_update_engine::Extent* add_dst_extents();
  const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent >&
      dst_extents() const;

  // optional bytes data_sha256_hash = 8;
  bool has_data_sha256_hash() const;
  void clear_data_sha256_hash();
  static const int kDataSha256HashFieldNumber = 8;
  const ::std::string& data_sha256_hash() const;
  void set_data_sha256_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_data_sha256_hash(::std::string&& value);
  #endif
  void set_data_sha256_hash(const char* value);
  void set_data_sha256_hash(const void* value, size_t size);
  ::std::string* mutable_data_sha256_hash();
  ::std::string* release_data_sha256_hash();
  void set_allocated_data_sha256_hash(::std::string* data_sha256_hash);

  // optional bytes src_sha256_hash = 9;
  bool has_src_sha256_hash() const;
  void clear_src_sha256_hash();
  static const int kSrcSha256HashFieldNumber = 9;
  const ::std::string& src_sha256_hash() const;
  void set_src_sha256_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_src_sha256_hash(::std::string&& value);
  #endif
  void set_src_sha256_hash(const char* value);
  void set_src_sha256_hash(const void* value, size_t size);
  ::std::string* mutable_src_sha256_hash();
  ::std::string* release_src_sha256_hash();
  void set_allocated_src_sha256_hash(::std::string* src_sha256_hash);

  // optional uint64 data_offset = 2;
  bool has_data_offset() const;
  void clear_data_offset();
  static const int kDataOffsetFieldNumber = 2;
  ::google::protobuf::uint64 data_offset() const;
  void set_data_offset(::google::protobuf::uint64 value);

  // optional uint64 data_length = 3;
  bool has_data_length() const;
  void clear_data_length();
  static const int kDataLengthFieldNumber = 3;
  ::google::protobuf::uint64 data_length() const;
  void set_data_length(::google::protobuf::uint64 value);

  // optional uint64 src_length = 5;
  bool has_src_length() const;
  void clear_src_length();
  static const int kSrcLengthFieldNumber = 5;
  ::google::protobuf::uint64 src_length() const;
  void set_src_length(::google::protobuf::uint64 value);

  // optional uint64 dst_length = 7;
  bool has_dst_length() const;
  void clear_dst_length();
  static const int kDstLengthFieldNumber = 7;
  ::google::protobuf::uint64 dst_length() const;
  void set_dst_length(::google::protobuf::uint64 value);

  // required .chromeos_update_engine.InstallOperation.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::chromeos_update_engine::InstallOperation_Type type() const;
  void set_type(::chromeos_update_engine::InstallOperation_Type value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.InstallOperation)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent > src_extents_;
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent > dst_extents_;
  ::google::protobuf::internal::ArenaStringPtr data_sha256_hash_;
  ::google::protobuf::internal::ArenaStringPtr src_sha256_hash_;
  ::google::protobuf::uint64 data_offset_;
  ::google::protobuf::uint64 data_length_;
  ::google::protobuf::uint64 src_length_;
  ::google::protobuf::uint64 dst_length_;
  int type_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class CowMergeOperation :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.CowMergeOperation) */ {
 public:
  CowMergeOperation();
  virtual ~CowMergeOperation();

  CowMergeOperation(const CowMergeOperation& from);

  inline CowMergeOperation& operator=(const CowMergeOperation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CowMergeOperation(CowMergeOperation&& from) noexcept
    : CowMergeOperation() {
    *this = ::std::move(from);
  }

  inline CowMergeOperation& operator=(CowMergeOperation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CowMergeOperation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CowMergeOperation* internal_default_instance() {
    return reinterpret_cast<const CowMergeOperation*>(
               &_CowMergeOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CowMergeOperation* other);
  friend void swap(CowMergeOperation& a, CowMergeOperation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CowMergeOperation* New() const final {
    return CreateMaybeMessage<CowMergeOperation>(nullptr);
  }

  CowMergeOperation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CowMergeOperation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const CowMergeOperation& from);
  void MergeFrom(const CowMergeOperation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CowMergeOperation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CowMergeOperation_Type Type;
  static const Type COW_COPY =
    CowMergeOperation_Type_COW_COPY;
  static const Type COW_XOR =
    CowMergeOperation_Type_COW_XOR;
  static const Type COW_REPLACE =
    CowMergeOperation_Type_COW_REPLACE;
  static inline bool Type_IsValid(int value) {
    return CowMergeOperation_Type_IsValid(value);
  }
  static const Type Type_MIN =
    CowMergeOperation_Type_Type_MIN;
  static const Type Type_MAX =
    CowMergeOperation_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    CowMergeOperation_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .chromeos_update_engine.Extent src_extent = 2;
  bool has_src_extent() const;
  void clear_src_extent();
  static const int kSrcExtentFieldNumber = 2;
  const ::chromeos_update_engine::Extent& src_extent() const;
  ::chromeos_update_engine::Extent* release_src_extent();
  ::chromeos_update_engine::Extent* mutable_src_extent();
  void set_allocated_src_extent(::chromeos_update_engine::Extent* src_extent);

  // optional .chromeos_update_engine.Extent dst_extent = 3;
  bool has_dst_extent() const;
  void clear_dst_extent();
  static const int kDstExtentFieldNumber = 3;
  const ::chromeos_update_engine::Extent& dst_extent() const;
  ::chromeos_update_engine::Extent* release_dst_extent();
  ::chromeos_update_engine::Extent* mutable_dst_extent();
  void set_allocated_dst_extent(::chromeos_update_engine::Extent* dst_extent);

  // optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::chromeos_update_engine::CowMergeOperation_Type type() const;
  void set_type(::chromeos_update_engine::CowMergeOperation_Type value);

  // optional uint32 src_offset = 4;
  bool has_src_offset() const;
  void clear_src_offset();
  static const int kSrcOffsetFieldNumber = 4;
  ::google::protobuf::uint32 src_offset() const;
  void set_src_offset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.CowMergeOperation)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::chromeos_update_engine::Extent* src_extent_;
  ::chromeos_update_engine::Extent* dst_extent_;
  int type_;
  ::google::protobuf::uint32 src_offset_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class PartitionUpdate :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.PartitionUpdate) */ {
 public:
  PartitionUpdate();
  virtual ~PartitionUpdate();

  PartitionUpdate(const PartitionUpdate& from);

  inline PartitionUpdate& operator=(const PartitionUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartitionUpdate(PartitionUpdate&& from) noexcept
    : PartitionUpdate() {
    *this = ::std::move(from);
  }

  inline PartitionUpdate& operator=(PartitionUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PartitionUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartitionUpdate* internal_default_instance() {
    return reinterpret_cast<const PartitionUpdate*>(
               &_PartitionUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(PartitionUpdate* other);
  friend void swap(PartitionUpdate& a, PartitionUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartitionUpdate* New() const final {
    return CreateMaybeMessage<PartitionUpdate>(nullptr);
  }

  PartitionUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PartitionUpdate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const PartitionUpdate& from);
  void MergeFrom(const PartitionUpdate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PartitionUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
  int new_partition_signature_size() const;
  void clear_new_partition_signature();
  static const int kNewPartitionSignatureFieldNumber = 5;
  ::chromeos_update_engine::Signatures_Signature* mutable_new_partition_signature(int index);
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >*
      mutable_new_partition_signature();
  const ::chromeos_update_engine::Signatures_Signature& new_partition_signature(int index) const;
  ::chromeos_update_engine::Signatures_Signature* add_new_partition_signature();
  const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >&
      new_partition_signature() const;

  // repeated .chromeos_update_engine.InstallOperation operations = 8;
  int operations_size() const;
  void clear_operations();
  static const int kOperationsFieldNumber = 8;
  ::chromeos_update_engine::InstallOperation* mutable_operations(int index);
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >*
      mutable_operations();
  const ::chromeos_update_engine::InstallOperation& operations(int index) const;
  ::chromeos_update_engine::InstallOperation* add_operations();
  const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >&
      operations() const;

  // repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
  int merge_operations_size() const;
  void clear_merge_operations();
  static const int kMergeOperationsFieldNumber = 18;
  ::chromeos_update_engine::CowMergeOperation* mutable_merge_operations(int index);
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::CowMergeOperation >*
      mutable_merge_operations();
  const ::chromeos_update_engine::CowMergeOperation& merge_operations(int index) const;
  ::chromeos_update_engine::CowMergeOperation* add_merge_operations();
  const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::CowMergeOperation >&
      merge_operations() const;

  // required string partition_name = 1;
  bool has_partition_name() const;
  void clear_partition_name();
  static const int kPartitionNameFieldNumber = 1;
  const ::std::string& partition_name() const;
  void set_partition_name(const ::std::string& value);
  #if LANG_CXX11
  void set_partition_name(::std::string&& value);
  #endif
  void set_partition_name(const char* value);
  void set_partition_name(const char* value, size_t size);
  ::std::string* mutable_partition_name();
  ::std::string* release_partition_name();
  void set_allocated_partition_name(::std::string* partition_name);

  // optional string postinstall_path = 3;
  bool has_postinstall_path() const;
  void clear_postinstall_path();
  static const int kPostinstallPathFieldNumber = 3;
  const ::std::string& postinstall_path() const;
  void set_postinstall_path(const ::std::string& value);
  #if LANG_CXX11
  void set_postinstall_path(::std::string&& value);
  #endif
  void set_postinstall_path(const char* value);
  void set_postinstall_path(const char* value, size_t size);
  ::std::string* mutable_postinstall_path();
  ::std::string* release_postinstall_path();
  void set_allocated_postinstall_path(::std::string* postinstall_path);

  // optional string filesystem_type = 4;
  bool has_filesystem_type() const;
  void clear_filesystem_type();
  static const int kFilesystemTypeFieldNumber = 4;
  const ::std::string& filesystem_type() const;
  void set_filesystem_type(const ::std::string& value);
  #if LANG_CXX11
  void set_filesystem_type(::std::string&& value);
  #endif
  void set_filesystem_type(const char* value);
  void set_filesystem_type(const char* value, size_t size);
  ::std::string* mutable_filesystem_type();
  ::std::string* release_filesystem_type();
  void set_allocated_filesystem_type(::std::string* filesystem_type);

  // optional string hash_tree_algorithm = 12;
  bool has_hash_tree_algorithm() const;
  void clear_hash_tree_algorithm();
  static const int kHashTreeAlgorithmFieldNumber = 12;
  const ::std::string& hash_tree_algorithm() const;
  void set_hash_tree_algorithm(const ::std::string& value);
  #if LANG_CXX11
  void set_hash_tree_algorithm(::std::string&& value);
  #endif
  void set_hash_tree_algorithm(const char* value);
  void set_hash_tree_algorithm(const char* value, size_t size);
  ::std::string* mutable_hash_tree_algorithm();
  ::std::string* release_hash_tree_algorithm();
  void set_allocated_hash_tree_algorithm(::std::string* hash_tree_algorithm);

  // optional bytes hash_tree_salt = 13;
  bool has_hash_tree_salt() const;
  void clear_hash_tree_salt();
  static const int kHashTreeSaltFieldNumber = 13;
  const ::std::string& hash_tree_salt() const;
  void set_hash_tree_salt(const ::std::string& value);
  #if LANG_CXX11
  void set_hash_tree_salt(::std::string&& value);
  #endif
  void set_hash_tree_salt(const char* value);
  void set_hash_tree_salt(const void* value, size_t size);
  ::std::string* mutable_hash_tree_salt();
  ::std::string* release_hash_tree_salt();
  void set_allocated_hash_tree_salt(::std::string* hash_tree_salt);

  // optional string version = 17;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 17;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
  bool has_old_partition_info() const;
  void clear_old_partition_info();
  static const int kOldPartitionInfoFieldNumber = 6;
  const ::chromeos_update_engine::PartitionInfo& old_partition_info() const;
  ::chromeos_update_engine::PartitionInfo* release_old_partition_info();
  ::chromeos_update_engine::PartitionInfo* mutable_old_partition_info();
  void set_allocated_old_partition_info(::chromeos_update_engine::PartitionInfo* old_partition_info);

  // optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
  bool has_new_partition_info() const;
  void clear_new_partition_info();
  static const int kNewPartitionInfoFieldNumber = 7;
  const ::chromeos_update_engine::PartitionInfo& new_partition_info() const;
  ::chromeos_update_engine::PartitionInfo* release_new_partition_info();
  ::chromeos_update_engine::PartitionInfo* mutable_new_partition_info();
  void set_allocated_new_partition_info(::chromeos_update_engine::PartitionInfo* new_partition_info);

  // optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
  bool has_hash_tree_data_extent() const;
  void clear_hash_tree_data_extent();
  static const int kHashTreeDataExtentFieldNumber = 10;
  const ::chromeos_update_engine::Extent& hash_tree_data_extent() const;
  ::chromeos_update_engine::Extent* release_hash_tree_data_extent();
  ::chromeos_update_engine::Extent* mutable_hash_tree_data_extent();
  void set_allocated_hash_tree_data_extent(::chromeos_update_engine::Extent* hash_tree_data_extent);

  // optional .chromeos_update_engine.Extent hash_tree_extent = 11;
  bool has_hash_tree_extent() const;
  void clear_hash_tree_extent();
  static const int kHashTreeExtentFieldNumber = 11;
  const ::chromeos_update_engine::Extent& hash_tree_extent() const;
  ::chromeos_update_engine::Extent* release_hash_tree_extent();
  ::chromeos_update_engine::Extent* mutable_hash_tree_extent();
  void set_allocated_hash_tree_extent(::chromeos_update_engine::Extent* hash_tree_extent);

  // optional .chromeos_update_engine.Extent fec_data_extent = 14;
  bool has_fec_data_extent() const;
  void clear_fec_data_extent();
  static const int kFecDataExtentFieldNumber = 14;
  const ::chromeos_update_engine::Extent& fec_data_extent() const;
  ::chromeos_update_engine::Extent* release_fec_data_extent();
  ::chromeos_update_engine::Extent* mutable_fec_data_extent();
  void set_allocated_fec_data_extent(::chromeos_update_engine::Extent* fec_data_extent);

  // optional .chromeos_update_engine.Extent fec_extent = 15;
  bool has_fec_extent() const;
  void clear_fec_extent();
  static const int kFecExtentFieldNumber = 15;
  const ::chromeos_update_engine::Extent& fec_extent() const;
  ::chromeos_update_engine::Extent* release_fec_extent();
  ::chromeos_update_engine::Extent* mutable_fec_extent();
  void set_allocated_fec_extent(::chromeos_update_engine::Extent* fec_extent);

  // optional uint64 estimate_cow_size = 19;
  bool has_estimate_cow_size() const;
  void clear_estimate_cow_size();
  static const int kEstimateCowSizeFieldNumber = 19;
  ::google::protobuf::uint64 estimate_cow_size() const;
  void set_estimate_cow_size(::google::protobuf::uint64 value);

  // optional bool run_postinstall = 2;
  bool has_run_postinstall() const;
  void clear_run_postinstall();
  static const int kRunPostinstallFieldNumber = 2;
  bool run_postinstall() const;
  void set_run_postinstall(bool value);

  // optional bool postinstall_optional = 9;
  bool has_postinstall_optional() const;
  void clear_postinstall_optional();
  static const int kPostinstallOptionalFieldNumber = 9;
  bool postinstall_optional() const;
  void set_postinstall_optional(bool value);

  // optional uint32 fec_roots = 16 [default = 2];
  bool has_fec_roots() const;
  void clear_fec_roots();
  static const int kFecRootsFieldNumber = 16;
  ::google::protobuf::uint32 fec_roots() const;
  void set_fec_roots(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionUpdate)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature > new_partition_signature_;
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation > operations_;
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::CowMergeOperation > merge_operations_;
  ::google::protobuf::internal::ArenaStringPtr partition_name_;
  ::google::protobuf::internal::ArenaStringPtr postinstall_path_;
  ::google::protobuf::internal::ArenaStringPtr filesystem_type_;
  ::google::protobuf::internal::ArenaStringPtr hash_tree_algorithm_;
  ::google::protobuf::internal::ArenaStringPtr hash_tree_salt_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::chromeos_update_engine::PartitionInfo* old_partition_info_;
  ::chromeos_update_engine::PartitionInfo* new_partition_info_;
  ::chromeos_update_engine::Extent* hash_tree_data_extent_;
  ::chromeos_update_engine::Extent* hash_tree_extent_;
  ::chromeos_update_engine::Extent* fec_data_extent_;
  ::chromeos_update_engine::Extent* fec_extent_;
  ::google::protobuf::uint64 estimate_cow_size_;
  bool run_postinstall_;
  bool postinstall_optional_;
  ::google::protobuf::uint32 fec_roots_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class DynamicPartitionGroup :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.DynamicPartitionGroup) */ {
 public:
  DynamicPartitionGroup();
  virtual ~DynamicPartitionGroup();

  DynamicPartitionGroup(const DynamicPartitionGroup& from);

  inline DynamicPartitionGroup& operator=(const DynamicPartitionGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DynamicPartitionGroup(DynamicPartitionGroup&& from) noexcept
    : DynamicPartitionGroup() {
    *this = ::std::move(from);
  }

  inline DynamicPartitionGroup& operator=(DynamicPartitionGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DynamicPartitionGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DynamicPartitionGroup* internal_default_instance() {
    return reinterpret_cast<const DynamicPartitionGroup*>(
               &_DynamicPartitionGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(DynamicPartitionGroup* other);
  friend void swap(DynamicPartitionGroup& a, DynamicPartitionGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DynamicPartitionGroup* New() const final {
    return CreateMaybeMessage<DynamicPartitionGroup>(nullptr);
  }

  DynamicPartitionGroup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DynamicPartitionGroup>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DynamicPartitionGroup& from);
  void MergeFrom(const DynamicPartitionGroup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DynamicPartitionGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string partition_names = 3;
  int partition_names_size() const;
  void clear_partition_names();
  static const int kPartitionNamesFieldNumber = 3;
  const ::std::string& partition_names(int index) const;
  ::std::string* mutable_partition_names(int index);
  void set_partition_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_partition_names(int index, ::std::string&& value);
  #endif
  void set_partition_names(int index, const char* value);
  void set_partition_names(int index, const char* value, size_t size);
  ::std::string* add_partition_names();
  void add_partition_names(const ::std::string& value);
  #if LANG_CXX11
  void add_partition_names(::std::string&& value);
  #endif
  void add_partition_names(const char* value);
  void add_partition_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& partition_names() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_partition_names();

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint64 size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.DynamicPartitionGroup)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField<::std::string> partition_names_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 size_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class VABCFeatureSet :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.VABCFeatureSet) */ {
 public:
  VABCFeatureSet();
  virtual ~VABCFeatureSet();

  VABCFeatureSet(const VABCFeatureSet& from);

  inline VABCFeatureSet& operator=(const VABCFeatureSet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VABCFeatureSet(VABCFeatureSet&& from) noexcept
    : VABCFeatureSet() {
    *this = ::std::move(from);
  }

  inline VABCFeatureSet& operator=(VABCFeatureSet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VABCFeatureSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VABCFeatureSet* internal_default_instance() {
    return reinterpret_cast<const VABCFeatureSet*>(
               &_VABCFeatureSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(VABCFeatureSet* other);
  friend void swap(VABCFeatureSet& a, VABCFeatureSet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VABCFeatureSet* New() const final {
    return CreateMaybeMessage<VABCFeatureSet>(nullptr);
  }

  VABCFeatureSet* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VABCFeatureSet>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const VABCFeatureSet& from);
  void MergeFrom(const VABCFeatureSet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VABCFeatureSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool threaded = 1;
  bool has_threaded() const;
  void clear_threaded();
  static const int kThreadedFieldNumber = 1;
  bool threaded() const;
  void set_threaded(bool value);

  // optional bool batch_writes = 2;
  bool has_batch_writes() const;
  void clear_batch_writes();
  static const int kBatchWritesFieldNumber = 2;
  bool batch_writes() const;
  void set_batch_writes(bool value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.VABCFeatureSet)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool threaded_;
  bool batch_writes_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class DynamicPartitionMetadata :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.DynamicPartitionMetadata) */ {
 public:
  DynamicPartitionMetadata();
  virtual ~DynamicPartitionMetadata();

  DynamicPartitionMetadata(const DynamicPartitionMetadata& from);

  inline DynamicPartitionMetadata& operator=(const DynamicPartitionMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DynamicPartitionMetadata(DynamicPartitionMetadata&& from) noexcept
    : DynamicPartitionMetadata() {
    *this = ::std::move(from);
  }

  inline DynamicPartitionMetadata& operator=(DynamicPartitionMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DynamicPartitionMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DynamicPartitionMetadata* internal_default_instance() {
    return reinterpret_cast<const DynamicPartitionMetadata*>(
               &_DynamicPartitionMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(DynamicPartitionMetadata* other);
  friend void swap(DynamicPartitionMetadata& a, DynamicPartitionMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DynamicPartitionMetadata* New() const final {
    return CreateMaybeMessage<DynamicPartitionMetadata>(nullptr);
  }

  DynamicPartitionMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DynamicPartitionMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DynamicPartitionMetadata& from);
  void MergeFrom(const DynamicPartitionMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DynamicPartitionMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
  int groups_size() const;
  void clear_groups();
  static const int kGroupsFieldNumber = 1;
  ::chromeos_update_engine::DynamicPartitionGroup* mutable_groups(int index);
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::DynamicPartitionGroup >*
      mutable_groups();
  const ::chromeos_update_engine::DynamicPartitionGroup& groups(int index) const;
  ::chromeos_update_engine::DynamicPartitionGroup* add_groups();
  const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::DynamicPartitionGroup >&
      groups() const;

  // optional string vabc_compression_param = 4;
  bool has_vabc_compression_param() const;
  void clear_vabc_compression_param();
  static const int kVabcCompressionParamFieldNumber = 4;
  const ::std::string& vabc_compression_param() const;
  void set_vabc_compression_param(const ::std::string& value);
  #if LANG_CXX11
  void set_vabc_compression_param(::std::string&& value);
  #endif
  void set_vabc_compression_param(const char* value);
  void set_vabc_compression_param(const char* value, size_t size);
  ::std::string* mutable_vabc_compression_param();
  ::std::string* release_vabc_compression_param();
  void set_allocated_vabc_compression_param(::std::string* vabc_compression_param);

  // optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;
  bool has_vabc_feature_set() const;
  void clear_vabc_feature_set();
  static const int kVabcFeatureSetFieldNumber = 6;
  const ::chromeos_update_engine::VABCFeatureSet& vabc_feature_set() const;
  ::chromeos_update_engine::VABCFeatureSet* release_vabc_feature_set();
  ::chromeos_update_engine::VABCFeatureSet* mutable_vabc_feature_set();
  void set_allocated_vabc_feature_set(::chromeos_update_engine::VABCFeatureSet* vabc_feature_set);

  // optional bool snapshot_enabled = 2;
  bool has_snapshot_enabled() const;
  void clear_snapshot_enabled();
  static const int kSnapshotEnabledFieldNumber = 2;
  bool snapshot_enabled() const;
  void set_snapshot_enabled(bool value);

  // optional bool vabc_enabled = 3;
  bool has_vabc_enabled() const;
  void clear_vabc_enabled();
  static const int kVabcEnabledFieldNumber = 3;
  bool vabc_enabled() const;
  void set_vabc_enabled(bool value);

  // optional uint32 cow_version = 5;
  bool has_cow_version() const;
  void clear_cow_version();
  static const int kCowVersionFieldNumber = 5;
  ::google::protobuf::uint32 cow_version() const;
  void set_cow_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.DynamicPartitionMetadata)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::DynamicPartitionGroup > groups_;
  ::google::protobuf::internal::ArenaStringPtr vabc_compression_param_;
  ::chromeos_update_engine::VABCFeatureSet* vabc_feature_set_;
  bool snapshot_enabled_;
  bool vabc_enabled_;
  ::google::protobuf::uint32 cow_version_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ApexInfo :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.ApexInfo) */ {
 public:
  ApexInfo();
  virtual ~ApexInfo();

  ApexInfo(const ApexInfo& from);

  inline ApexInfo& operator=(const ApexInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ApexInfo(ApexInfo&& from) noexcept
    : ApexInfo() {
    *this = ::std::move(from);
  }

  inline ApexInfo& operator=(ApexInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ApexInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApexInfo* internal_default_instance() {
    return reinterpret_cast<const ApexInfo*>(
               &_ApexInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ApexInfo* other);
  friend void swap(ApexInfo& a, ApexInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ApexInfo* New() const final {
    return CreateMaybeMessage<ApexInfo>(nullptr);
  }

  ApexInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ApexInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ApexInfo& from);
  void MergeFrom(const ApexInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ApexInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string package_name = 1;
  bool has_package_name() const;
  void clear_package_name();
  static const int kPackageNameFieldNumber = 1;
  const ::std::string& package_name() const;
  void set_package_name(const ::std::string& value);
  #if LANG_CXX11
  void set_package_name(::std::string&& value);
  #endif
  void set_package_name(const char* value);
  void set_package_name(const char* value, size_t size);
  ::std::string* mutable_package_name();
  ::std::string* release_package_name();
  void set_allocated_package_name(::std::string* package_name);

  // optional int64 version = 2;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::google::protobuf::int64 version() const;
  void set_version(::google::protobuf::int64 value);

  // optional int64 decompressed_size = 4;
  bool has_decompressed_size() const;
  void clear_decompressed_size();
  static const int kDecompressedSizeFieldNumber = 4;
  ::google::protobuf::int64 decompressed_size() const;
  void set_decompressed_size(::google::protobuf::int64 value);

  // optional bool is_compressed = 3;
  bool has_is_compressed() const;
  void clear_is_compressed();
  static const int kIsCompressedFieldNumber = 3;
  bool is_compressed() const;
  void set_is_compressed(bool value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.ApexInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr package_name_;
  ::google::protobuf::int64 version_;
  ::google::protobuf::int64 decompressed_size_;
  bool is_compressed_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class ApexMetadata :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.ApexMetadata) */ {
 public:
  ApexMetadata();
  virtual ~ApexMetadata();

  ApexMetadata(const ApexMetadata& from);

  inline ApexMetadata& operator=(const ApexMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ApexMetadata(ApexMetadata&& from) noexcept
    : ApexMetadata() {
    *this = ::std::move(from);
  }

  inline ApexMetadata& operator=(ApexMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ApexMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApexMetadata* internal_default_instance() {
    return reinterpret_cast<const ApexMetadata*>(
               &_ApexMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ApexMetadata* other);
  friend void swap(ApexMetadata& a, ApexMetadata& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ApexMetadata* New() const final {
    return CreateMaybeMessage<ApexMetadata>(nullptr);
  }

  ApexMetadata* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ApexMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const ApexMetadata& from);
  void MergeFrom(const ApexMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ApexMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .chromeos_update_engine.ApexInfo apex_info = 1;
  int apex_info_size() const;
  void clear_apex_info();
  static const int kApexInfoFieldNumber = 1;
  ::chromeos_update_engine::ApexInfo* mutable_apex_info(int index);
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >*
      mutable_apex_info();
  const ::chromeos_update_engine::ApexInfo& apex_info(int index) const;
  ::chromeos_update_engine::ApexInfo* add_apex_info();
  const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >&
      apex_info() const;

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.ApexMetadata)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::ApexInfo > apex_info_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class DeltaArchiveManifest :
    public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.DeltaArchiveManifest) */ {
 public:
  DeltaArchiveManifest();
  virtual ~DeltaArchiveManifest();

  DeltaArchiveManifest(const DeltaArchiveManifest& from);

  inline DeltaArchiveManifest& operator=(const DeltaArchiveManifest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeltaArchiveManifest(DeltaArchiveManifest&& from) noexcept
    : DeltaArchiveManifest() {
    *this = ::std::move(from);
  }

  inline DeltaArchiveManifest& operator=(DeltaArchiveManifest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DeltaArchiveManifest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeltaArchiveManifest* internal_default_instance() {
    return reinterpret_cast<const DeltaArchiveManifest*>(
               &_DeltaArchiveManifest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(DeltaArchiveManifest* other);
  friend void swap(DeltaArchiveManifest& a, DeltaArchiveManifest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeltaArchiveManifest* New() const final {
    return CreateMaybeMessage<DeltaArchiveManifest>(nullptr);
  }

  DeltaArchiveManifest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeltaArchiveManifest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const DeltaArchiveManifest& from);
  void MergeFrom(const DeltaArchiveManifest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeltaArchiveManifest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
  int partitions_size() const;
  void clear_partitions();
  static const int kPartitionsFieldNumber = 13;
  ::chromeos_update_engine::PartitionUpdate* mutable_partitions(int index);
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate >*
      mutable_partitions();
  const ::chromeos_update_engine::PartitionUpdate& partitions(int index) const;
  ::chromeos_update_engine::PartitionUpdate* add_partitions();
  const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate >&
      partitions() const;

  // repeated .chromeos_update_engine.ApexInfo apex_info = 17;
  int apex_info_size() const;
  void clear_apex_info();
  static const int kApexInfoFieldNumber = 17;
  ::chromeos_update_engine::ApexInfo* mutable_apex_info(int index);
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >*
      mutable_apex_info();
  const ::chromeos_update_engine::ApexInfo& apex_info(int index) const;
  ::chromeos_update_engine::ApexInfo* add_apex_info();
  const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >&
      apex_info() const;

  // optional string security_patch_level = 18;
  bool has_security_patch_level() const;
  void clear_security_patch_level();
  static const int kSecurityPatchLevelFieldNumber = 18;
  const ::std::string& security_patch_level() const;
  void set_security_patch_level(const ::std::string& value);
  #if LANG_CXX11
  void set_security_patch_level(::std::string&& value);
  #endif
  void set_security_patch_level(const char* value);
  void set_security_patch_level(const char* value, size_t size);
  ::std::string* mutable_security_patch_level();
  ::std::string* release_security_patch_level();
  void set_allocated_security_patch_level(::std::string* security_patch_level);

  // optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
  bool has_dynamic_partition_metadata() const;
  void clear_dynamic_partition_metadata();
  static const int kDynamicPartitionMetadataFieldNumber = 15;
  const ::chromeos_update_engine::DynamicPartitionMetadata& dynamic_partition_metadata() const;
  ::chromeos_update_engine::DynamicPartitionMetadata* release_dynamic_partition_metadata();
  ::chromeos_update_engine::DynamicPartitionMetadata* mutable_dynamic_partition_metadata();
  void set_allocated_dynamic_partition_metadata(::chromeos_update_engine::DynamicPartitionMetadata* dynamic_partition_metadata);

  // optional uint64 signatures_offset = 4;
  bool has_signatures_offset() const;
  void clear_signatures_offset();
  static const int kSignaturesOffsetFieldNumber = 4;
  ::google::protobuf::uint64 signatures_offset() const;
  void set_signatures_offset(::google::protobuf::uint64 value);

  // optional uint64 signatures_size = 5;
  bool has_signatures_size() const;
  void clear_signatures_size();
  static const int kSignaturesSizeFieldNumber = 5;
  ::google::protobuf::uint64 signatures_size() const;
  void set_signatures_size(::google::protobuf::uint64 value);

  // optional int64 max_timestamp = 14;
  bool has_max_timestamp() const;
  void clear_max_timestamp();
  static const int kMaxTimestampFieldNumber = 14;
  ::google::protobuf::int64 max_timestamp() const;
  void set_max_timestamp(::google::protobuf::int64 value);

  // optional uint32 minor_version = 12 [default = 0];
  bool has_minor_version() const;
  void clear_minor_version();
  static const int kMinorVersionFieldNumber = 12;
  ::google::protobuf::uint32 minor_version() const;
  void set_minor_version(::google::protobuf::uint32 value);

  // optional bool partial_update = 16;
  bool has_partial_update() const;
  void clear_partial_update();
  static const int kPartialUpdateFieldNumber = 16;
  bool partial_update() const;
  void set_partial_update(bool value);

  // optional uint32 block_size = 3 [default = 4096];
  bool has_block_size() const;
  void clear_block_size();
  static const int kBlockSizeFieldNumber = 3;
  ::google::protobuf::uint32 block_size() const;
  void set_block_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.DeltaArchiveManifest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate > partitions_;
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::ApexInfo > apex_info_;
  ::google::protobuf::internal::ArenaStringPtr security_patch_level_;
  ::chromeos_update_engine::DynamicPartitionMetadata* dynamic_partition_metadata_;
  ::google::protobuf::uint64 signatures_offset_;
  ::google::protobuf::uint64 signatures_size_;
  ::google::protobuf::int64 max_timestamp_;
  ::google::protobuf::uint32 minor_version_;
  bool partial_update_;
  ::google::protobuf::uint32 block_size_;
  friend struct ::TableStruct_update_5fmetadata_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Extent

// optional uint64 start_block = 1;
inline bool Extent::has_start_block() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Extent::clear_start_block() {
  start_block_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 Extent::start_block() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Extent.start_block)
  return start_block_;
}
inline void Extent::set_start_block(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  start_block_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Extent.start_block)
}

// optional uint64 num_blocks = 2;
inline bool Extent::has_num_blocks() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Extent::clear_num_blocks() {
  num_blocks_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 Extent::num_blocks() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Extent.num_blocks)
  return num_blocks_;
}
inline void Extent::set_num_blocks(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  num_blocks_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Extent.num_blocks)
}

// -------------------------------------------------------------------

// Signatures_Signature

// optional uint32 version = 1 [deprecated = true];
inline bool Signatures_Signature::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Signatures_Signature::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 Signatures_Signature::version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Signatures.Signature.version)
  return version_;
}
inline void Signatures_Signature::set_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  version_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Signatures.Signature.version)
}

// optional bytes data = 2;
inline bool Signatures_Signature::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signatures_Signature::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Signatures_Signature::data() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Signatures.Signature.data)
  return data_.GetNoArena();
}
inline void Signatures_Signature::set_data(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Signatures.Signature.data)
}
#if LANG_CXX11
inline void Signatures_Signature::set_data(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.Signatures.Signature.data)
}
#endif
inline void Signatures_Signature::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.Signatures.Signature.data)
}
inline void Signatures_Signature::set_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.Signatures.Signature.data)
}
inline ::std::string* Signatures_Signature::mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.Signatures.Signature.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Signatures_Signature::release_data() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.Signatures.Signature.data)
  if (!has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signatures_Signature::set_allocated_data(::std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.Signatures.Signature.data)
}

// optional fixed32 unpadded_signature_size = 3;
inline bool Signatures_Signature::has_unpadded_signature_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Signatures_Signature::clear_unpadded_signature_size() {
  unpadded_signature_size_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 Signatures_Signature::unpadded_signature_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Signatures.Signature.unpadded_signature_size)
  return unpadded_signature_size_;
}
inline void Signatures_Signature::set_unpadded_signature_size(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  unpadded_signature_size_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Signatures.Signature.unpadded_signature_size)
}

// -------------------------------------------------------------------

// Signatures

// repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
inline int Signatures::signatures_size() const {
  return signatures_.size();
}
inline void Signatures::clear_signatures() {
  signatures_.Clear();
}
inline ::chromeos_update_engine::Signatures_Signature* Signatures::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.Signatures.signatures)
  return signatures_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >*
Signatures::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.Signatures.signatures)
  return &signatures_;
}
inline const ::chromeos_update_engine::Signatures_Signature& Signatures::signatures(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Signatures.signatures)
  return signatures_.Get(index);
}
inline ::chromeos_update_engine::Signatures_Signature* Signatures::add_signatures() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.Signatures.signatures)
  return signatures_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >&
Signatures::signatures() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.Signatures.signatures)
  return signatures_;
}

// -------------------------------------------------------------------

// PartitionInfo

// optional uint64 size = 1;
inline bool PartitionInfo::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PartitionInfo::clear_size() {
  size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 PartitionInfo::size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionInfo.size)
  return size_;
}
inline void PartitionInfo::set_size(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  size_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionInfo.size)
}

// optional bytes hash = 2;
inline bool PartitionInfo::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PartitionInfo::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& PartitionInfo::hash() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionInfo.hash)
  return hash_.GetNoArena();
}
inline void PartitionInfo::set_hash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionInfo.hash)
}
#if LANG_CXX11
inline void PartitionInfo::set_hash(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.PartitionInfo.hash)
}
#endif
inline void PartitionInfo::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.PartitionInfo.hash)
}
inline void PartitionInfo::set_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.PartitionInfo.hash)
}
inline ::std::string* PartitionInfo::mutable_hash() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionInfo.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionInfo::release_hash() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionInfo.hash)
  if (!has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionInfo::set_allocated_hash(::std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionInfo.hash)
}

// -------------------------------------------------------------------

// InstallOperation

// required .chromeos_update_engine.InstallOperation.Type type = 1;
inline bool InstallOperation::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InstallOperation::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::chromeos_update_engine::InstallOperation_Type InstallOperation::type() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.type)
  return static_cast< ::chromeos_update_engine::InstallOperation_Type >(type_);
}
inline void InstallOperation::set_type(::chromeos_update_engine::InstallOperation_Type value) {
  assert(::chromeos_update_engine::InstallOperation_Type_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  type_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.type)
}

// optional uint64 data_offset = 2;
inline bool InstallOperation::has_data_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstallOperation::clear_data_offset() {
  data_offset_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 InstallOperation::data_offset() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.data_offset)
  return data_offset_;
}
inline void InstallOperation::set_data_offset(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  data_offset_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.data_offset)
}

// optional uint64 data_length = 3;
inline bool InstallOperation::has_data_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstallOperation::clear_data_length() {
  data_length_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 InstallOperation::data_length() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.data_length)
  return data_length_;
}
inline void InstallOperation::set_data_length(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  data_length_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.data_length)
}

// repeated .chromeos_update_engine.Extent src_extents = 4;
inline int InstallOperation::src_extents_size() const {
  return src_extents_.size();
}
inline void InstallOperation::clear_src_extents() {
  src_extents_.Clear();
}
inline ::chromeos_update_engine::Extent* InstallOperation::mutable_src_extents(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.src_extents)
  return src_extents_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent >*
InstallOperation::mutable_src_extents() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.InstallOperation.src_extents)
  return &src_extents_;
}
inline const ::chromeos_update_engine::Extent& InstallOperation::src_extents(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.src_extents)
  return src_extents_.Get(index);
}
inline ::chromeos_update_engine::Extent* InstallOperation::add_src_extents() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.InstallOperation.src_extents)
  return src_extents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent >&
InstallOperation::src_extents() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.InstallOperation.src_extents)
  return src_extents_;
}

// optional uint64 src_length = 5;
inline bool InstallOperation::has_src_length() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstallOperation::clear_src_length() {
  src_length_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint64 InstallOperation::src_length() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.src_length)
  return src_length_;
}
inline void InstallOperation::set_src_length(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  src_length_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.src_length)
}

// repeated .chromeos_update_engine.Extent dst_extents = 6;
inline int InstallOperation::dst_extents_size() const {
  return dst_extents_.size();
}
inline void InstallOperation::clear_dst_extents() {
  dst_extents_.Clear();
}
inline ::chromeos_update_engine::Extent* InstallOperation::mutable_dst_extents(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.dst_extents)
  return dst_extents_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent >*
InstallOperation::mutable_dst_extents() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.InstallOperation.dst_extents)
  return &dst_extents_;
}
inline const ::chromeos_update_engine::Extent& InstallOperation::dst_extents(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.dst_extents)
  return dst_extents_.Get(index);
}
inline ::chromeos_update_engine::Extent* InstallOperation::add_dst_extents() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.InstallOperation.dst_extents)
  return dst_extents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent >&
InstallOperation::dst_extents() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.InstallOperation.dst_extents)
  return dst_extents_;
}

// optional uint64 dst_length = 7;
inline bool InstallOperation::has_dst_length() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InstallOperation::clear_dst_length() {
  dst_length_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint64 InstallOperation::dst_length() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.dst_length)
  return dst_length_;
}
inline void InstallOperation::set_dst_length(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  dst_length_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.dst_length)
}

// optional bytes data_sha256_hash = 8;
inline bool InstallOperation::has_data_sha256_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstallOperation::clear_data_sha256_hash() {
  data_sha256_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& InstallOperation::data_sha256_hash() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.data_sha256_hash)
  return data_sha256_hash_.GetNoArena();
}
inline void InstallOperation::set_data_sha256_hash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_sha256_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.data_sha256_hash)
}
#if LANG_CXX11
inline void InstallOperation::set_data_sha256_hash(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  data_sha256_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.InstallOperation.data_sha256_hash)
}
#endif
inline void InstallOperation::set_data_sha256_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  data_sha256_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.InstallOperation.data_sha256_hash)
}
inline void InstallOperation::set_data_sha256_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  data_sha256_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.InstallOperation.data_sha256_hash)
}
inline ::std::string* InstallOperation::mutable_data_sha256_hash() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.data_sha256_hash)
  return data_sha256_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstallOperation::release_data_sha256_hash() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.InstallOperation.data_sha256_hash)
  if (!has_data_sha256_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return data_sha256_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstallOperation::set_allocated_data_sha256_hash(::std::string* data_sha256_hash) {
  if (data_sha256_hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_sha256_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_sha256_hash);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.InstallOperation.data_sha256_hash)
}

// optional bytes src_sha256_hash = 9;
inline bool InstallOperation::has_src_sha256_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstallOperation::clear_src_sha256_hash() {
  src_sha256_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& InstallOperation::src_sha256_hash() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.src_sha256_hash)
  return src_sha256_hash_.GetNoArena();
}
inline void InstallOperation::set_src_sha256_hash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  src_sha256_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.src_sha256_hash)
}
#if LANG_CXX11
inline void InstallOperation::set_src_sha256_hash(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  src_sha256_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.InstallOperation.src_sha256_hash)
}
#endif
inline void InstallOperation::set_src_sha256_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  src_sha256_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.InstallOperation.src_sha256_hash)
}
inline void InstallOperation::set_src_sha256_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  src_sha256_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.InstallOperation.src_sha256_hash)
}
inline ::std::string* InstallOperation::mutable_src_sha256_hash() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.src_sha256_hash)
  return src_sha256_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstallOperation::release_src_sha256_hash() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.InstallOperation.src_sha256_hash)
  if (!has_src_sha256_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return src_sha256_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstallOperation::set_allocated_src_sha256_hash(::std::string* src_sha256_hash) {
  if (src_sha256_hash != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  src_sha256_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src_sha256_hash);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.InstallOperation.src_sha256_hash)
}

// -------------------------------------------------------------------

// CowMergeOperation

// optional .chromeos_update_engine.CowMergeOperation.Type type = 1;
inline bool CowMergeOperation::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CowMergeOperation::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::chromeos_update_engine::CowMergeOperation_Type CowMergeOperation::type() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.CowMergeOperation.type)
  return static_cast< ::chromeos_update_engine::CowMergeOperation_Type >(type_);
}
inline void CowMergeOperation::set_type(::chromeos_update_engine::CowMergeOperation_Type value) {
  assert(::chromeos_update_engine::CowMergeOperation_Type_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.CowMergeOperation.type)
}

// optional .chromeos_update_engine.Extent src_extent = 2;
inline bool CowMergeOperation::has_src_extent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CowMergeOperation::clear_src_extent() {
  if (src_extent_ != nullptr) src_extent_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::chromeos_update_engine::Extent& CowMergeOperation::src_extent() const {
  const ::chromeos_update_engine::Extent* p = src_extent_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.CowMergeOperation.src_extent)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::Extent*>(
      &::chromeos_update_engine::_Extent_default_instance_);
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::release_src_extent() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.CowMergeOperation.src_extent)
  _has_bits_[0] &= ~0x00000001u;
  ::chromeos_update_engine::Extent* temp = src_extent_;
  src_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::mutable_src_extent() {
  _has_bits_[0] |= 0x00000001u;
  if (src_extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::Extent>(GetArenaNoVirtual());
    src_extent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.CowMergeOperation.src_extent)
  return src_extent_;
}
inline void CowMergeOperation::set_allocated_src_extent(::chromeos_update_engine::Extent* src_extent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete src_extent_;
  }
  if (src_extent) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      src_extent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, src_extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  src_extent_ = src_extent;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.CowMergeOperation.src_extent)
}

// optional .chromeos_update_engine.Extent dst_extent = 3;
inline bool CowMergeOperation::has_dst_extent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CowMergeOperation::clear_dst_extent() {
  if (dst_extent_ != nullptr) dst_extent_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::chromeos_update_engine::Extent& CowMergeOperation::dst_extent() const {
  const ::chromeos_update_engine::Extent* p = dst_extent_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.CowMergeOperation.dst_extent)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::Extent*>(
      &::chromeos_update_engine::_Extent_default_instance_);
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::release_dst_extent() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.CowMergeOperation.dst_extent)
  _has_bits_[0] &= ~0x00000002u;
  ::chromeos_update_engine::Extent* temp = dst_extent_;
  dst_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* CowMergeOperation::mutable_dst_extent() {
  _has_bits_[0] |= 0x00000002u;
  if (dst_extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::Extent>(GetArenaNoVirtual());
    dst_extent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.CowMergeOperation.dst_extent)
  return dst_extent_;
}
inline void CowMergeOperation::set_allocated_dst_extent(::chromeos_update_engine::Extent* dst_extent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dst_extent_;
  }
  if (dst_extent) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dst_extent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dst_extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  dst_extent_ = dst_extent;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.CowMergeOperation.dst_extent)
}

// optional uint32 src_offset = 4;
inline bool CowMergeOperation::has_src_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CowMergeOperation::clear_src_offset() {
  src_offset_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 CowMergeOperation::src_offset() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.CowMergeOperation.src_offset)
  return src_offset_;
}
inline void CowMergeOperation::set_src_offset(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  src_offset_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.CowMergeOperation.src_offset)
}

// -------------------------------------------------------------------

// PartitionUpdate

// required string partition_name = 1;
inline bool PartitionUpdate::has_partition_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PartitionUpdate::clear_partition_name() {
  partition_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& PartitionUpdate::partition_name() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.partition_name)
  return partition_name_.GetNoArena();
}
inline void PartitionUpdate::set_partition_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  partition_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.partition_name)
}
#if LANG_CXX11
inline void PartitionUpdate::set_partition_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  partition_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.PartitionUpdate.partition_name)
}
#endif
inline void PartitionUpdate::set_partition_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  partition_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.PartitionUpdate.partition_name)
}
inline void PartitionUpdate::set_partition_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  partition_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.PartitionUpdate.partition_name)
}
inline ::std::string* PartitionUpdate::mutable_partition_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.partition_name)
  return partition_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionUpdate::release_partition_name() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.partition_name)
  if (!has_partition_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return partition_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionUpdate::set_allocated_partition_name(::std::string* partition_name) {
  if (partition_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  partition_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), partition_name);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.partition_name)
}

// optional bool run_postinstall = 2;
inline bool PartitionUpdate::has_run_postinstall() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PartitionUpdate::clear_run_postinstall() {
  run_postinstall_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool PartitionUpdate::run_postinstall() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.run_postinstall)
  return run_postinstall_;
}
inline void PartitionUpdate::set_run_postinstall(bool value) {
  _has_bits_[0] |= 0x00002000u;
  run_postinstall_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.run_postinstall)
}

// optional string postinstall_path = 3;
inline bool PartitionUpdate::has_postinstall_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PartitionUpdate::clear_postinstall_path() {
  postinstall_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& PartitionUpdate::postinstall_path() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.postinstall_path)
  return postinstall_path_.GetNoArena();
}
inline void PartitionUpdate::set_postinstall_path(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  postinstall_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.postinstall_path)
}
#if LANG_CXX11
inline void PartitionUpdate::set_postinstall_path(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  postinstall_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.PartitionUpdate.postinstall_path)
}
#endif
inline void PartitionUpdate::set_postinstall_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  postinstall_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.PartitionUpdate.postinstall_path)
}
inline void PartitionUpdate::set_postinstall_path(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  postinstall_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.PartitionUpdate.postinstall_path)
}
inline ::std::string* PartitionUpdate::mutable_postinstall_path() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.postinstall_path)
  return postinstall_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionUpdate::release_postinstall_path() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.postinstall_path)
  if (!has_postinstall_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return postinstall_path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionUpdate::set_allocated_postinstall_path(::std::string* postinstall_path) {
  if (postinstall_path != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  postinstall_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), postinstall_path);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.postinstall_path)
}

// optional string filesystem_type = 4;
inline bool PartitionUpdate::has_filesystem_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PartitionUpdate::clear_filesystem_type() {
  filesystem_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& PartitionUpdate::filesystem_type() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.filesystem_type)
  return filesystem_type_.GetNoArena();
}
inline void PartitionUpdate::set_filesystem_type(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  filesystem_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.filesystem_type)
}
#if LANG_CXX11
inline void PartitionUpdate::set_filesystem_type(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  filesystem_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.PartitionUpdate.filesystem_type)
}
#endif
inline void PartitionUpdate::set_filesystem_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  filesystem_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.PartitionUpdate.filesystem_type)
}
inline void PartitionUpdate::set_filesystem_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  filesystem_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.PartitionUpdate.filesystem_type)
}
inline ::std::string* PartitionUpdate::mutable_filesystem_type() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.filesystem_type)
  return filesystem_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionUpdate::release_filesystem_type() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.filesystem_type)
  if (!has_filesystem_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return filesystem_type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionUpdate::set_allocated_filesystem_type(::std::string* filesystem_type) {
  if (filesystem_type != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  filesystem_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filesystem_type);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.filesystem_type)
}

// repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
inline int PartitionUpdate::new_partition_signature_size() const {
  return new_partition_signature_.size();
}
inline void PartitionUpdate::clear_new_partition_signature() {
  new_partition_signature_.Clear();
}
inline ::chromeos_update_engine::Signatures_Signature* PartitionUpdate::mutable_new_partition_signature(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return new_partition_signature_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >*
PartitionUpdate::mutable_new_partition_signature() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return &new_partition_signature_;
}
inline const ::chromeos_update_engine::Signatures_Signature& PartitionUpdate::new_partition_signature(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return new_partition_signature_.Get(index);
}
inline ::chromeos_update_engine::Signatures_Signature* PartitionUpdate::add_new_partition_signature() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return new_partition_signature_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >&
PartitionUpdate::new_partition_signature() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return new_partition_signature_;
}

// optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
inline bool PartitionUpdate::has_old_partition_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PartitionUpdate::clear_old_partition_info() {
  if (old_partition_info_ != nullptr) old_partition_info_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::chromeos_update_engine::PartitionInfo& PartitionUpdate::old_partition_info() const {
  const ::chromeos_update_engine::PartitionInfo* p = old_partition_info_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.old_partition_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::PartitionInfo*>(
      &::chromeos_update_engine::_PartitionInfo_default_instance_);
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::release_old_partition_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.old_partition_info)
  _has_bits_[0] &= ~0x00000040u;
  ::chromeos_update_engine::PartitionInfo* temp = old_partition_info_;
  old_partition_info_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::mutable_old_partition_info() {
  _has_bits_[0] |= 0x00000040u;
  if (old_partition_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::PartitionInfo>(GetArenaNoVirtual());
    old_partition_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.old_partition_info)
  return old_partition_info_;
}
inline void PartitionUpdate::set_allocated_old_partition_info(::chromeos_update_engine::PartitionInfo* old_partition_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete old_partition_info_;
  }
  if (old_partition_info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      old_partition_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, old_partition_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  old_partition_info_ = old_partition_info;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.old_partition_info)
}

// optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
inline bool PartitionUpdate::has_new_partition_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PartitionUpdate::clear_new_partition_info() {
  if (new_partition_info_ != nullptr) new_partition_info_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::chromeos_update_engine::PartitionInfo& PartitionUpdate::new_partition_info() const {
  const ::chromeos_update_engine::PartitionInfo* p = new_partition_info_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.new_partition_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::PartitionInfo*>(
      &::chromeos_update_engine::_PartitionInfo_default_instance_);
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::release_new_partition_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.new_partition_info)
  _has_bits_[0] &= ~0x00000080u;
  ::chromeos_update_engine::PartitionInfo* temp = new_partition_info_;
  new_partition_info_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::mutable_new_partition_info() {
  _has_bits_[0] |= 0x00000080u;
  if (new_partition_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::PartitionInfo>(GetArenaNoVirtual());
    new_partition_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.new_partition_info)
  return new_partition_info_;
}
inline void PartitionUpdate::set_allocated_new_partition_info(::chromeos_update_engine::PartitionInfo* new_partition_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete new_partition_info_;
  }
  if (new_partition_info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      new_partition_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, new_partition_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  new_partition_info_ = new_partition_info;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.new_partition_info)
}

// repeated .chromeos_update_engine.InstallOperation operations = 8;
inline int PartitionUpdate::operations_size() const {
  return operations_.size();
}
inline void PartitionUpdate::clear_operations() {
  operations_.Clear();
}
inline ::chromeos_update_engine::InstallOperation* PartitionUpdate::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.operations)
  return operations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >*
PartitionUpdate::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.PartitionUpdate.operations)
  return &operations_;
}
inline const ::chromeos_update_engine::InstallOperation& PartitionUpdate::operations(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.operations)
  return operations_.Get(index);
}
inline ::chromeos_update_engine::InstallOperation* PartitionUpdate::add_operations() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.PartitionUpdate.operations)
  return operations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >&
PartitionUpdate::operations() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.PartitionUpdate.operations)
  return operations_;
}

// optional bool postinstall_optional = 9;
inline bool PartitionUpdate::has_postinstall_optional() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PartitionUpdate::clear_postinstall_optional() {
  postinstall_optional_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool PartitionUpdate::postinstall_optional() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.postinstall_optional)
  return postinstall_optional_;
}
inline void PartitionUpdate::set_postinstall_optional(bool value) {
  _has_bits_[0] |= 0x00004000u;
  postinstall_optional_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.postinstall_optional)
}

// optional .chromeos_update_engine.Extent hash_tree_data_extent = 10;
inline bool PartitionUpdate::has_hash_tree_data_extent() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PartitionUpdate::clear_hash_tree_data_extent() {
  if (hash_tree_data_extent_ != nullptr) hash_tree_data_extent_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::hash_tree_data_extent() const {
  const ::chromeos_update_engine::Extent* p = hash_tree_data_extent_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.hash_tree_data_extent)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::Extent*>(
      &::chromeos_update_engine::_Extent_default_instance_);
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::release_hash_tree_data_extent() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.hash_tree_data_extent)
  _has_bits_[0] &= ~0x00000100u;
  ::chromeos_update_engine::Extent* temp = hash_tree_data_extent_;
  hash_tree_data_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::mutable_hash_tree_data_extent() {
  _has_bits_[0] |= 0x00000100u;
  if (hash_tree_data_extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::Extent>(GetArenaNoVirtual());
    hash_tree_data_extent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.hash_tree_data_extent)
  return hash_tree_data_extent_;
}
inline void PartitionUpdate::set_allocated_hash_tree_data_extent(::chromeos_update_engine::Extent* hash_tree_data_extent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete hash_tree_data_extent_;
  }
  if (hash_tree_data_extent) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      hash_tree_data_extent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hash_tree_data_extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  hash_tree_data_extent_ = hash_tree_data_extent;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_data_extent)
}

// optional .chromeos_update_engine.Extent hash_tree_extent = 11;
inline bool PartitionUpdate::has_hash_tree_extent() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PartitionUpdate::clear_hash_tree_extent() {
  if (hash_tree_extent_ != nullptr) hash_tree_extent_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::hash_tree_extent() const {
  const ::chromeos_update_engine::Extent* p = hash_tree_extent_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.hash_tree_extent)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::Extent*>(
      &::chromeos_update_engine::_Extent_default_instance_);
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::release_hash_tree_extent() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.hash_tree_extent)
  _has_bits_[0] &= ~0x00000200u;
  ::chromeos_update_engine::Extent* temp = hash_tree_extent_;
  hash_tree_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::mutable_hash_tree_extent() {
  _has_bits_[0] |= 0x00000200u;
  if (hash_tree_extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::Extent>(GetArenaNoVirtual());
    hash_tree_extent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.hash_tree_extent)
  return hash_tree_extent_;
}
inline void PartitionUpdate::set_allocated_hash_tree_extent(::chromeos_update_engine::Extent* hash_tree_extent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete hash_tree_extent_;
  }
  if (hash_tree_extent) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      hash_tree_extent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hash_tree_extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  hash_tree_extent_ = hash_tree_extent;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_extent)
}

// optional string hash_tree_algorithm = 12;
inline bool PartitionUpdate::has_hash_tree_algorithm() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PartitionUpdate::clear_hash_tree_algorithm() {
  hash_tree_algorithm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& PartitionUpdate::hash_tree_algorithm() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
  return hash_tree_algorithm_.GetNoArena();
}
inline void PartitionUpdate::set_hash_tree_algorithm(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  hash_tree_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
}
#if LANG_CXX11
inline void PartitionUpdate::set_hash_tree_algorithm(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  hash_tree_algorithm_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
}
#endif
inline void PartitionUpdate::set_hash_tree_algorithm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  hash_tree_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
}
inline void PartitionUpdate::set_hash_tree_algorithm(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  hash_tree_algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
}
inline ::std::string* PartitionUpdate::mutable_hash_tree_algorithm() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
  return hash_tree_algorithm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionUpdate::release_hash_tree_algorithm() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
  if (!has_hash_tree_algorithm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return hash_tree_algorithm_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionUpdate::set_allocated_hash_tree_algorithm(::std::string* hash_tree_algorithm) {
  if (hash_tree_algorithm != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  hash_tree_algorithm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash_tree_algorithm);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_algorithm)
}

// optional bytes hash_tree_salt = 13;
inline bool PartitionUpdate::has_hash_tree_salt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PartitionUpdate::clear_hash_tree_salt() {
  hash_tree_salt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& PartitionUpdate::hash_tree_salt() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
  return hash_tree_salt_.GetNoArena();
}
inline void PartitionUpdate::set_hash_tree_salt(const ::std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  hash_tree_salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
}
#if LANG_CXX11
inline void PartitionUpdate::set_hash_tree_salt(::std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  hash_tree_salt_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
}
#endif
inline void PartitionUpdate::set_hash_tree_salt(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  hash_tree_salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
}
inline void PartitionUpdate::set_hash_tree_salt(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  hash_tree_salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
}
inline ::std::string* PartitionUpdate::mutable_hash_tree_salt() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
  return hash_tree_salt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionUpdate::release_hash_tree_salt() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
  if (!has_hash_tree_salt()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return hash_tree_salt_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionUpdate::set_allocated_hash_tree_salt(::std::string* hash_tree_salt) {
  if (hash_tree_salt != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  hash_tree_salt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash_tree_salt);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.hash_tree_salt)
}

// optional .chromeos_update_engine.Extent fec_data_extent = 14;
inline bool PartitionUpdate::has_fec_data_extent() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PartitionUpdate::clear_fec_data_extent() {
  if (fec_data_extent_ != nullptr) fec_data_extent_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::fec_data_extent() const {
  const ::chromeos_update_engine::Extent* p = fec_data_extent_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.fec_data_extent)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::Extent*>(
      &::chromeos_update_engine::_Extent_default_instance_);
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::release_fec_data_extent() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.fec_data_extent)
  _has_bits_[0] &= ~0x00000400u;
  ::chromeos_update_engine::Extent* temp = fec_data_extent_;
  fec_data_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::mutable_fec_data_extent() {
  _has_bits_[0] |= 0x00000400u;
  if (fec_data_extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::Extent>(GetArenaNoVirtual());
    fec_data_extent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.fec_data_extent)
  return fec_data_extent_;
}
inline void PartitionUpdate::set_allocated_fec_data_extent(::chromeos_update_engine::Extent* fec_data_extent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete fec_data_extent_;
  }
  if (fec_data_extent) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fec_data_extent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fec_data_extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  fec_data_extent_ = fec_data_extent;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.fec_data_extent)
}

// optional .chromeos_update_engine.Extent fec_extent = 15;
inline bool PartitionUpdate::has_fec_extent() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PartitionUpdate::clear_fec_extent() {
  if (fec_extent_ != nullptr) fec_extent_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::chromeos_update_engine::Extent& PartitionUpdate::fec_extent() const {
  const ::chromeos_update_engine::Extent* p = fec_extent_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.fec_extent)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::Extent*>(
      &::chromeos_update_engine::_Extent_default_instance_);
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::release_fec_extent() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.fec_extent)
  _has_bits_[0] &= ~0x00000800u;
  ::chromeos_update_engine::Extent* temp = fec_extent_;
  fec_extent_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::Extent* PartitionUpdate::mutable_fec_extent() {
  _has_bits_[0] |= 0x00000800u;
  if (fec_extent_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::Extent>(GetArenaNoVirtual());
    fec_extent_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.fec_extent)
  return fec_extent_;
}
inline void PartitionUpdate::set_allocated_fec_extent(::chromeos_update_engine::Extent* fec_extent) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete fec_extent_;
  }
  if (fec_extent) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fec_extent = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fec_extent, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  fec_extent_ = fec_extent;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.fec_extent)
}

// optional uint32 fec_roots = 16 [default = 2];
inline bool PartitionUpdate::has_fec_roots() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PartitionUpdate::clear_fec_roots() {
  fec_roots_ = 2u;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::google::protobuf::uint32 PartitionUpdate::fec_roots() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.fec_roots)
  return fec_roots_;
}
inline void PartitionUpdate::set_fec_roots(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00008000u;
  fec_roots_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.fec_roots)
}

// optional string version = 17;
inline bool PartitionUpdate::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PartitionUpdate::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::std::string& PartitionUpdate::version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.version)
  return version_.GetNoArena();
}
inline void PartitionUpdate::set_version(const ::std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.version)
}
#if LANG_CXX11
inline void PartitionUpdate::set_version(::std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.PartitionUpdate.version)
}
#endif
inline void PartitionUpdate::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.PartitionUpdate.version)
}
inline void PartitionUpdate::set_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.PartitionUpdate.version)
}
inline ::std::string* PartitionUpdate::mutable_version() {
  _has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionUpdate::release_version() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.version)
  if (!has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionUpdate::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.version)
}

// repeated .chromeos_update_engine.CowMergeOperation merge_operations = 18;
inline int PartitionUpdate::merge_operations_size() const {
  return merge_operations_.size();
}
inline void PartitionUpdate::clear_merge_operations() {
  merge_operations_.Clear();
}
inline ::chromeos_update_engine::CowMergeOperation* PartitionUpdate::mutable_merge_operations(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.merge_operations)
  return merge_operations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::CowMergeOperation >*
PartitionUpdate::mutable_merge_operations() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.PartitionUpdate.merge_operations)
  return &merge_operations_;
}
inline const ::chromeos_update_engine::CowMergeOperation& PartitionUpdate::merge_operations(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.merge_operations)
  return merge_operations_.Get(index);
}
inline ::chromeos_update_engine::CowMergeOperation* PartitionUpdate::add_merge_operations() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.PartitionUpdate.merge_operations)
  return merge_operations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::CowMergeOperation >&
PartitionUpdate::merge_operations() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.PartitionUpdate.merge_operations)
  return merge_operations_;
}

// optional uint64 estimate_cow_size = 19;
inline bool PartitionUpdate::has_estimate_cow_size() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PartitionUpdate::clear_estimate_cow_size() {
  estimate_cow_size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00001000u;
}
inline ::google::protobuf::uint64 PartitionUpdate::estimate_cow_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.estimate_cow_size)
  return estimate_cow_size_;
}
inline void PartitionUpdate::set_estimate_cow_size(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00001000u;
  estimate_cow_size_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.estimate_cow_size)
}

// -------------------------------------------------------------------

// DynamicPartitionGroup

// required string name = 1;
inline bool DynamicPartitionGroup::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DynamicPartitionGroup::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DynamicPartitionGroup::name() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionGroup.name)
  return name_.GetNoArena();
}
inline void DynamicPartitionGroup::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionGroup.name)
}
#if LANG_CXX11
inline void DynamicPartitionGroup::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.DynamicPartitionGroup.name)
}
#endif
inline void DynamicPartitionGroup::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.DynamicPartitionGroup.name)
}
inline void DynamicPartitionGroup::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.DynamicPartitionGroup.name)
}
inline ::std::string* DynamicPartitionGroup::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DynamicPartitionGroup.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DynamicPartitionGroup::release_name() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DynamicPartitionGroup.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DynamicPartitionGroup::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DynamicPartitionGroup.name)
}

// optional uint64 size = 2;
inline bool DynamicPartitionGroup::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DynamicPartitionGroup::clear_size() {
  size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint64 DynamicPartitionGroup::size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionGroup.size)
  return size_;
}
inline void DynamicPartitionGroup::set_size(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  size_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionGroup.size)
}

// repeated string partition_names = 3;
inline int DynamicPartitionGroup::partition_names_size() const {
  return partition_names_.size();
}
inline void DynamicPartitionGroup::clear_partition_names() {
  partition_names_.Clear();
}
inline const ::std::string& DynamicPartitionGroup::partition_names(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  return partition_names_.Get(index);
}
inline ::std::string* DynamicPartitionGroup::mutable_partition_names(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  return partition_names_.Mutable(index);
}
inline void DynamicPartitionGroup::set_partition_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  partition_names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DynamicPartitionGroup::set_partition_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  partition_names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DynamicPartitionGroup::set_partition_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  partition_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
inline void DynamicPartitionGroup::set_partition_names(int index, const char* value, size_t size) {
  partition_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
inline ::std::string* DynamicPartitionGroup::add_partition_names() {
  // @@protoc_insertion_point(field_add_mutable:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  return partition_names_.Add();
}
inline void DynamicPartitionGroup::add_partition_names(const ::std::string& value) {
  partition_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
#if LANG_CXX11
inline void DynamicPartitionGroup::add_partition_names(::std::string&& value) {
  partition_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
#endif
inline void DynamicPartitionGroup::add_partition_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  partition_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
inline void DynamicPartitionGroup::add_partition_names(const char* value, size_t size) {
  partition_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:chromeos_update_engine.DynamicPartitionGroup.partition_names)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
DynamicPartitionGroup::partition_names() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  return partition_names_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
DynamicPartitionGroup::mutable_partition_names() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DynamicPartitionGroup.partition_names)
  return &partition_names_;
}

// -------------------------------------------------------------------

// VABCFeatureSet

// optional bool threaded = 1;
inline bool VABCFeatureSet::has_threaded() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VABCFeatureSet::clear_threaded() {
  threaded_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool VABCFeatureSet::threaded() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.VABCFeatureSet.threaded)
  return threaded_;
}
inline void VABCFeatureSet::set_threaded(bool value) {
  _has_bits_[0] |= 0x00000001u;
  threaded_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.VABCFeatureSet.threaded)
}

// optional bool batch_writes = 2;
inline bool VABCFeatureSet::has_batch_writes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VABCFeatureSet::clear_batch_writes() {
  batch_writes_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool VABCFeatureSet::batch_writes() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.VABCFeatureSet.batch_writes)
  return batch_writes_;
}
inline void VABCFeatureSet::set_batch_writes(bool value) {
  _has_bits_[0] |= 0x00000002u;
  batch_writes_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.VABCFeatureSet.batch_writes)
}

// -------------------------------------------------------------------

// DynamicPartitionMetadata

// repeated .chromeos_update_engine.DynamicPartitionGroup groups = 1;
inline int DynamicPartitionMetadata::groups_size() const {
  return groups_.size();
}
inline void DynamicPartitionMetadata::clear_groups() {
  groups_.Clear();
}
inline ::chromeos_update_engine::DynamicPartitionGroup* DynamicPartitionMetadata::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DynamicPartitionMetadata.groups)
  return groups_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::DynamicPartitionGroup >*
DynamicPartitionMetadata::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DynamicPartitionMetadata.groups)
  return &groups_;
}
inline const ::chromeos_update_engine::DynamicPartitionGroup& DynamicPartitionMetadata::groups(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.groups)
  return groups_.Get(index);
}
inline ::chromeos_update_engine::DynamicPartitionGroup* DynamicPartitionMetadata::add_groups() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DynamicPartitionMetadata.groups)
  return groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::DynamicPartitionGroup >&
DynamicPartitionMetadata::groups() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DynamicPartitionMetadata.groups)
  return groups_;
}

// optional bool snapshot_enabled = 2;
inline bool DynamicPartitionMetadata::has_snapshot_enabled() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DynamicPartitionMetadata::clear_snapshot_enabled() {
  snapshot_enabled_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool DynamicPartitionMetadata::snapshot_enabled() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.snapshot_enabled)
  return snapshot_enabled_;
}
inline void DynamicPartitionMetadata::set_snapshot_enabled(bool value) {
  _has_bits_[0] |= 0x00000004u;
  snapshot_enabled_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionMetadata.snapshot_enabled)
}

// optional bool vabc_enabled = 3;
inline bool DynamicPartitionMetadata::has_vabc_enabled() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DynamicPartitionMetadata::clear_vabc_enabled() {
  vabc_enabled_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool DynamicPartitionMetadata::vabc_enabled() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.vabc_enabled)
  return vabc_enabled_;
}
inline void DynamicPartitionMetadata::set_vabc_enabled(bool value) {
  _has_bits_[0] |= 0x00000008u;
  vabc_enabled_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionMetadata.vabc_enabled)
}

// optional string vabc_compression_param = 4;
inline bool DynamicPartitionMetadata::has_vabc_compression_param() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DynamicPartitionMetadata::clear_vabc_compression_param() {
  vabc_compression_param_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DynamicPartitionMetadata::vabc_compression_param() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
  return vabc_compression_param_.GetNoArena();
}
inline void DynamicPartitionMetadata::set_vabc_compression_param(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  vabc_compression_param_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
}
#if LANG_CXX11
inline void DynamicPartitionMetadata::set_vabc_compression_param(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  vabc_compression_param_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
}
#endif
inline void DynamicPartitionMetadata::set_vabc_compression_param(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  vabc_compression_param_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
}
inline void DynamicPartitionMetadata::set_vabc_compression_param(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  vabc_compression_param_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
}
inline ::std::string* DynamicPartitionMetadata::mutable_vabc_compression_param() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
  return vabc_compression_param_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DynamicPartitionMetadata::release_vabc_compression_param() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
  if (!has_vabc_compression_param()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return vabc_compression_param_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DynamicPartitionMetadata::set_allocated_vabc_compression_param(::std::string* vabc_compression_param) {
  if (vabc_compression_param != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  vabc_compression_param_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vabc_compression_param);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DynamicPartitionMetadata.vabc_compression_param)
}

// optional uint32 cow_version = 5;
inline bool DynamicPartitionMetadata::has_cow_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DynamicPartitionMetadata::clear_cow_version() {
  cow_version_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 DynamicPartitionMetadata::cow_version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.cow_version)
  return cow_version_;
}
inline void DynamicPartitionMetadata::set_cow_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  cow_version_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DynamicPartitionMetadata.cow_version)
}

// optional .chromeos_update_engine.VABCFeatureSet vabc_feature_set = 6;
inline bool DynamicPartitionMetadata::has_vabc_feature_set() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DynamicPartitionMetadata::clear_vabc_feature_set() {
  if (vabc_feature_set_ != nullptr) vabc_feature_set_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::chromeos_update_engine::VABCFeatureSet& DynamicPartitionMetadata::vabc_feature_set() const {
  const ::chromeos_update_engine::VABCFeatureSet* p = vabc_feature_set_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DynamicPartitionMetadata.vabc_feature_set)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::VABCFeatureSet*>(
      &::chromeos_update_engine::_VABCFeatureSet_default_instance_);
}
inline ::chromeos_update_engine::VABCFeatureSet* DynamicPartitionMetadata::release_vabc_feature_set() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DynamicPartitionMetadata.vabc_feature_set)
  _has_bits_[0] &= ~0x00000002u;
  ::chromeos_update_engine::VABCFeatureSet* temp = vabc_feature_set_;
  vabc_feature_set_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::VABCFeatureSet* DynamicPartitionMetadata::mutable_vabc_feature_set() {
  _has_bits_[0] |= 0x00000002u;
  if (vabc_feature_set_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::VABCFeatureSet>(GetArenaNoVirtual());
    vabc_feature_set_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DynamicPartitionMetadata.vabc_feature_set)
  return vabc_feature_set_;
}
inline void DynamicPartitionMetadata::set_allocated_vabc_feature_set(::chromeos_update_engine::VABCFeatureSet* vabc_feature_set) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete vabc_feature_set_;
  }
  if (vabc_feature_set) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      vabc_feature_set = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vabc_feature_set, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  vabc_feature_set_ = vabc_feature_set;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DynamicPartitionMetadata.vabc_feature_set)
}

// -------------------------------------------------------------------

// ApexInfo

// optional string package_name = 1;
inline bool ApexInfo::has_package_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApexInfo::clear_package_name() {
  package_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ApexInfo::package_name() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexInfo.package_name)
  return package_name_.GetNoArena();
}
inline void ApexInfo::set_package_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  package_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ApexInfo.package_name)
}
#if LANG_CXX11
inline void ApexInfo::set_package_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  package_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.ApexInfo.package_name)
}
#endif
inline void ApexInfo::set_package_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  package_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.ApexInfo.package_name)
}
inline void ApexInfo::set_package_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  package_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.ApexInfo.package_name)
}
inline ::std::string* ApexInfo::mutable_package_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ApexInfo.package_name)
  return package_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApexInfo::release_package_name() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.ApexInfo.package_name)
  if (!has_package_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return package_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApexInfo::set_allocated_package_name(::std::string* package_name) {
  if (package_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  package_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), package_name);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.ApexInfo.package_name)
}

// optional int64 version = 2;
inline bool ApexInfo::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApexInfo::clear_version() {
  version_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int64 ApexInfo::version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexInfo.version)
  return version_;
}
inline void ApexInfo::set_version(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  version_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ApexInfo.version)
}

// optional bool is_compressed = 3;
inline bool ApexInfo::has_is_compressed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApexInfo::clear_is_compressed() {
  is_compressed_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ApexInfo::is_compressed() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexInfo.is_compressed)
  return is_compressed_;
}
inline void ApexInfo::set_is_compressed(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_compressed_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ApexInfo.is_compressed)
}

// optional int64 decompressed_size = 4;
inline bool ApexInfo::has_decompressed_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApexInfo::clear_decompressed_size() {
  decompressed_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int64 ApexInfo::decompressed_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexInfo.decompressed_size)
  return decompressed_size_;
}
inline void ApexInfo::set_decompressed_size(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  decompressed_size_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ApexInfo.decompressed_size)
}

// -------------------------------------------------------------------

// ApexMetadata

// repeated .chromeos_update_engine.ApexInfo apex_info = 1;
inline int ApexMetadata::apex_info_size() const {
  return apex_info_.size();
}
inline void ApexMetadata::clear_apex_info() {
  apex_info_.Clear();
}
inline ::chromeos_update_engine::ApexInfo* ApexMetadata::mutable_apex_info(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ApexMetadata.apex_info)
  return apex_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >*
ApexMetadata::mutable_apex_info() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.ApexMetadata.apex_info)
  return &apex_info_;
}
inline const ::chromeos_update_engine::ApexInfo& ApexMetadata::apex_info(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ApexMetadata.apex_info)
  return apex_info_.Get(index);
}
inline ::chromeos_update_engine::ApexInfo* ApexMetadata::add_apex_info() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.ApexMetadata.apex_info)
  return apex_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >&
ApexMetadata::apex_info() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.ApexMetadata.apex_info)
  return apex_info_;
}

// -------------------------------------------------------------------

// DeltaArchiveManifest

// optional uint32 block_size = 3 [default = 4096];
inline bool DeltaArchiveManifest::has_block_size() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeltaArchiveManifest::clear_block_size() {
  block_size_ = 4096u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::google::protobuf::uint32 DeltaArchiveManifest::block_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.block_size)
  return block_size_;
}
inline void DeltaArchiveManifest::set_block_size(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  block_size_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.block_size)
}

// optional uint64 signatures_offset = 4;
inline bool DeltaArchiveManifest::has_signatures_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeltaArchiveManifest::clear_signatures_offset() {
  signatures_offset_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint64 DeltaArchiveManifest::signatures_offset() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.signatures_offset)
  return signatures_offset_;
}
inline void DeltaArchiveManifest::set_signatures_offset(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  signatures_offset_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.signatures_offset)
}

// optional uint64 signatures_size = 5;
inline bool DeltaArchiveManifest::has_signatures_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeltaArchiveManifest::clear_signatures_size() {
  signatures_size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 DeltaArchiveManifest::signatures_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.signatures_size)
  return signatures_size_;
}
inline void DeltaArchiveManifest::set_signatures_size(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  signatures_size_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.signatures_size)
}

// optional uint32 minor_version = 12 [default = 0];
inline bool DeltaArchiveManifest::has_minor_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeltaArchiveManifest::clear_minor_version() {
  minor_version_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 DeltaArchiveManifest::minor_version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.minor_version)
  return minor_version_;
}
inline void DeltaArchiveManifest::set_minor_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  minor_version_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.minor_version)
}

// repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
inline int DeltaArchiveManifest::partitions_size() const {
  return partitions_.size();
}
inline void DeltaArchiveManifest::clear_partitions() {
  partitions_.Clear();
}
inline ::chromeos_update_engine::PartitionUpdate* DeltaArchiveManifest::mutable_partitions(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return partitions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate >*
DeltaArchiveManifest::mutable_partitions() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return &partitions_;
}
inline const ::chromeos_update_engine::PartitionUpdate& DeltaArchiveManifest::partitions(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return partitions_.Get(index);
}
inline ::chromeos_update_engine::PartitionUpdate* DeltaArchiveManifest::add_partitions() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return partitions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate >&
DeltaArchiveManifest::partitions() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return partitions_;
}

// optional int64 max_timestamp = 14;
inline bool DeltaArchiveManifest::has_max_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeltaArchiveManifest::clear_max_timestamp() {
  max_timestamp_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::int64 DeltaArchiveManifest::max_timestamp() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.max_timestamp)
  return max_timestamp_;
}
inline void DeltaArchiveManifest::set_max_timestamp(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  max_timestamp_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.max_timestamp)
}

// optional .chromeos_update_engine.DynamicPartitionMetadata dynamic_partition_metadata = 15;
inline bool DeltaArchiveManifest::has_dynamic_partition_metadata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeltaArchiveManifest::clear_dynamic_partition_metadata() {
  if (dynamic_partition_metadata_ != nullptr) dynamic_partition_metadata_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::chromeos_update_engine::DynamicPartitionMetadata& DeltaArchiveManifest::dynamic_partition_metadata() const {
  const ::chromeos_update_engine::DynamicPartitionMetadata* p = dynamic_partition_metadata_;
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.dynamic_partition_metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::chromeos_update_engine::DynamicPartitionMetadata*>(
      &::chromeos_update_engine::_DynamicPartitionMetadata_default_instance_);
}
inline ::chromeos_update_engine::DynamicPartitionMetadata* DeltaArchiveManifest::release_dynamic_partition_metadata() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DeltaArchiveManifest.dynamic_partition_metadata)
  _has_bits_[0] &= ~0x00000002u;
  ::chromeos_update_engine::DynamicPartitionMetadata* temp = dynamic_partition_metadata_;
  dynamic_partition_metadata_ = nullptr;
  return temp;
}
inline ::chromeos_update_engine::DynamicPartitionMetadata* DeltaArchiveManifest::mutable_dynamic_partition_metadata() {
  _has_bits_[0] |= 0x00000002u;
  if (dynamic_partition_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::chromeos_update_engine::DynamicPartitionMetadata>(GetArenaNoVirtual());
    dynamic_partition_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.dynamic_partition_metadata)
  return dynamic_partition_metadata_;
}
inline void DeltaArchiveManifest::set_allocated_dynamic_partition_metadata(::chromeos_update_engine::DynamicPartitionMetadata* dynamic_partition_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete dynamic_partition_metadata_;
  }
  if (dynamic_partition_metadata) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dynamic_partition_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dynamic_partition_metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  dynamic_partition_metadata_ = dynamic_partition_metadata;
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DeltaArchiveManifest.dynamic_partition_metadata)
}

// optional bool partial_update = 16;
inline bool DeltaArchiveManifest::has_partial_update() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeltaArchiveManifest::clear_partial_update() {
  partial_update_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool DeltaArchiveManifest::partial_update() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.partial_update)
  return partial_update_;
}
inline void DeltaArchiveManifest::set_partial_update(bool value) {
  _has_bits_[0] |= 0x00000040u;
  partial_update_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.partial_update)
}

// repeated .chromeos_update_engine.ApexInfo apex_info = 17;
inline int DeltaArchiveManifest::apex_info_size() const {
  return apex_info_.size();
}
inline void DeltaArchiveManifest::clear_apex_info() {
  apex_info_.Clear();
}
inline ::chromeos_update_engine::ApexInfo* DeltaArchiveManifest::mutable_apex_info(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  return apex_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >*
DeltaArchiveManifest::mutable_apex_info() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  return &apex_info_;
}
inline const ::chromeos_update_engine::ApexInfo& DeltaArchiveManifest::apex_info(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  return apex_info_.Get(index);
}
inline ::chromeos_update_engine::ApexInfo* DeltaArchiveManifest::add_apex_info() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  return apex_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::ApexInfo >&
DeltaArchiveManifest::apex_info() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DeltaArchiveManifest.apex_info)
  return apex_info_;
}

// optional string security_patch_level = 18;
inline bool DeltaArchiveManifest::has_security_patch_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeltaArchiveManifest::clear_security_patch_level() {
  security_patch_level_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DeltaArchiveManifest::security_patch_level() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.security_patch_level)
  return security_patch_level_.GetNoArena();
}
inline void DeltaArchiveManifest::set_security_patch_level(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  security_patch_level_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.security_patch_level)
}
#if LANG_CXX11
inline void DeltaArchiveManifest::set_security_patch_level(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  security_patch_level_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chromeos_update_engine.DeltaArchiveManifest.security_patch_level)
}
#endif
inline void DeltaArchiveManifest::set_security_patch_level(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  security_patch_level_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.DeltaArchiveManifest.security_patch_level)
}
inline void DeltaArchiveManifest::set_security_patch_level(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  security_patch_level_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.DeltaArchiveManifest.security_patch_level)
}
inline ::std::string* DeltaArchiveManifest::mutable_security_patch_level() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.security_patch_level)
  return security_patch_level_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeltaArchiveManifest::release_security_patch_level() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DeltaArchiveManifest.security_patch_level)
  if (!has_security_patch_level()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return security_patch_level_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeltaArchiveManifest::set_allocated_security_patch_level(::std::string* security_patch_level) {
  if (security_patch_level != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  security_patch_level_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), security_patch_level);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DeltaArchiveManifest.security_patch_level)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chromeos_update_engine

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::chromeos_update_engine::InstallOperation_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::chromeos_update_engine::CowMergeOperation_Type> : ::std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_update_5fmetadata_2eproto
